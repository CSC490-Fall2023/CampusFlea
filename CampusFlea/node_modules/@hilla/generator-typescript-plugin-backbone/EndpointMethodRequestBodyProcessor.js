import { isEmptyObject, isObjectSchema, } from '@hilla/generator-typescript-core/Schema.js';
import ts from 'typescript';
import TypeSchemaProcessor from './TypeSchemaProcessor.js';
import { defaultMediaType } from './utils.js';
class EndpointMethodRequestBodyProcessor {
    static #defaultInitParamName = 'init';
    #dependencies;
    #owner;
    #requestBody;
    #initTypeIdentifier;
    constructor(requestBody, dependencies, owner, initTypeIdentifier) {
        this.#owner = owner;
        this.#dependencies = dependencies;
        this.#requestBody = requestBody ? owner.resolver.resolve(requestBody) : undefined;
        this.#initTypeIdentifier = initTypeIdentifier;
    }
    process() {
        if (!this.#requestBody) {
            return {
                initParam: ts.factory.createIdentifier(EndpointMethodRequestBodyProcessor.#defaultInitParamName),
                packedParameters: ts.factory.createObjectLiteralExpression(),
                parameters: [
                    ts.factory.createParameterDeclaration(undefined, undefined, EndpointMethodRequestBodyProcessor.#defaultInitParamName, ts.factory.createToken(ts.SyntaxKind.QuestionToken), ts.factory.createTypeReferenceNode(this.#initTypeIdentifier)),
                ],
            };
        }
        const parameterData = this.#extractParameterData(this.#requestBody.content[defaultMediaType].schema);
        const parameterNames = parameterData.map(([name]) => name);
        let initParamName = EndpointMethodRequestBodyProcessor.#defaultInitParamName;
        while (parameterNames.includes(initParamName)) {
            initParamName = `_${initParamName}`;
        }
        return {
            initParam: ts.factory.createIdentifier(initParamName),
            packedParameters: ts.factory.createObjectLiteralExpression(parameterData.map(([name]) => ts.factory.createShorthandPropertyAssignment(name))),
            parameters: [
                ...parameterData.map(([name, schema]) => {
                    const nodes = new TypeSchemaProcessor(schema, this.#dependencies).process();
                    return ts.factory.createParameterDeclaration(undefined, undefined, name, undefined, ts.factory.createUnionTypeNode(nodes));
                }),
                ts.factory.createParameterDeclaration(undefined, undefined, initParamName, ts.factory.createToken(ts.SyntaxKind.QuestionToken), ts.factory.createTypeReferenceNode(this.#initTypeIdentifier)),
            ],
        };
    }
    #extractParameterData(basicSchema) {
        if (!basicSchema) {
            return [];
        }
        const { resolver, logger } = this.#owner;
        const resolvedSchema = resolver.resolve(basicSchema);
        if (isObjectSchema(resolvedSchema) && !isEmptyObject(resolvedSchema)) {
            return Object.entries(resolvedSchema.properties);
        }
        logger.warn("A schema provided for endpoint method's 'requestBody' is not supported");
        return [];
    }
}
export default EndpointMethodRequestBodyProcessor;
//# sourceMappingURL=EndpointMethodRequestBodyProcessor.js.map