{
  "version": 3,
  "sources": ["src/Authentication.ts"],
  "sourcesContent": ["import type { MiddlewareClass, MiddlewareContext, MiddlewareNext } from './Connect.js';\nimport CookieManager from './CookieManager.js';\nimport { getSpringCsrfInfo, getSpringCsrfTokenHeadersForAuthRequest, VAADIN_CSRF_HEADER } from './CsrfUtils.js';\n\nconst JWT_COOKIE_NAME = 'jwt.headerAndPayload';\n\nfunction getSpringCsrfTokenFromResponseBody(body: string): Record<string, string> {\n  const doc = new DOMParser().parseFromString(body, 'text/html');\n  return getSpringCsrfInfo(doc);\n}\n\nfunction clearSpringCsrfMetaTags() {\n  Array.from(document.head.querySelectorAll('meta[name=\"_csrf\"], meta[name=\"_csrf_header\"]')).forEach((el) =>\n    el.remove(),\n  );\n}\n\nfunction updateSpringCsrfMetaTags(springCsrfInfo: Record<string, string>) {\n  clearSpringCsrfMetaTags();\n  const headerNameMeta: HTMLMetaElement = document.createElement('meta');\n  headerNameMeta.name = '_csrf_header';\n  headerNameMeta.content = springCsrfInfo._csrf_header;\n  document.head.appendChild(headerNameMeta);\n  const tokenMeta: HTMLMetaElement = document.createElement('meta');\n  tokenMeta.name = '_csrf';\n  tokenMeta.content = springCsrfInfo._csrf;\n  document.head.appendChild(tokenMeta);\n}\n\nconst getVaadinCsrfTokenFromResponseBody = (body: string): string | undefined => {\n  const match = /window\\.Vaadin = \\{TypeScript: \\{\"csrfToken\":\"([0-9a-zA-Z\\\\-]{36})\"\\}\\};/iu.exec(body);\n  return match ? match[1] : undefined;\n};\n\nasync function updateCsrfTokensBasedOnResponse(response: Response): Promise<string | undefined> {\n  const responseText = await response.text();\n  const token = getVaadinCsrfTokenFromResponseBody(responseText);\n  const springCsrfTokenInfo = getSpringCsrfTokenFromResponseBody(responseText);\n  updateSpringCsrfMetaTags(springCsrfTokenInfo);\n\n  return token;\n}\n\nasync function doLogout(logoutUrl: string, headers: Record<string, string>) {\n  const response = await fetch(logoutUrl, { headers, method: 'POST' });\n  if (!response.ok) {\n    throw new Error(`failed to logout with response ${response.status}`);\n  }\n\n  await updateCsrfTokensBasedOnResponse(response);\n}\n\nexport interface LoginResult {\n  error: boolean;\n  token?: string;\n  errorTitle?: string;\n  errorMessage?: string;\n  redirectUrl?: string;\n  defaultUrl?: string;\n}\n\nexport interface LoginOptions {\n  loginProcessingUrl?: string;\n}\n\nexport interface LogoutOptions {\n  logoutUrl?: string;\n}\n\n/**\n * A helper method for Spring Security based form login.\n * @param username - username\n * @param password - password\n * @param options - defines additional options, e.g, the loginProcessingUrl etc.\n */\nexport async function login(username: string, password: string, options?: LoginOptions): Promise<LoginResult> {\n  try {\n    const data = new FormData();\n    data.append('username', username);\n    data.append('password', password);\n\n    const loginProcessingUrl = options?.loginProcessingUrl ?? 'login';\n    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);\n    headers.source = 'typescript';\n    const response = await fetch(loginProcessingUrl, {\n      body: data,\n      headers,\n      method: 'POST',\n    });\n\n    // This code assumes that a VaadinSavedRequestAwareAuthenticationSuccessHandler is used on the server side,\n    // setting these header values based on the \"source=typescript\" header set above\n\n    const result = response.headers.get('Result');\n    const savedUrl = response.headers.get('Saved-url') ?? undefined;\n    const defaultUrl = response.headers.get('Default-url') ?? undefined;\n    const loginSuccessful = response.ok && result === 'success';\n\n    if (loginSuccessful) {\n      const vaadinCsrfToken = response.headers.get('Vaadin-CSRF') ?? undefined;\n\n      const springCsrfHeader = response.headers.get('Spring-CSRF-header') ?? undefined;\n      const springCsrfToken = response.headers.get('Spring-CSRF-token') ?? undefined;\n      if (springCsrfHeader && springCsrfToken) {\n        const springCsrfTokenInfo: Record<string, string> = {};\n        springCsrfTokenInfo._csrf = springCsrfToken;\n        // eslint-disable-next-line camelcase\n        springCsrfTokenInfo._csrf_header = springCsrfHeader;\n        updateSpringCsrfMetaTags(springCsrfTokenInfo);\n      }\n\n      return {\n        defaultUrl,\n        error: false,\n        redirectUrl: savedUrl,\n        token: vaadinCsrfToken,\n      };\n    }\n    return {\n      error: true,\n      errorMessage: 'Check that you have entered the correct username and password and try again.',\n      errorTitle: 'Incorrect username or password.',\n    };\n  } catch (e: unknown) {\n    if (e instanceof Error) {\n      return {\n        error: true,\n        errorMessage: e.message,\n        errorTitle: e.name,\n      };\n    }\n\n    throw e;\n  }\n}\n\n/**\n * A helper method for Spring Security based form logout\n * @param options - defines additional options, e.g, the logoutUrl.\n */\nexport async function logout(options?: LogoutOptions): Promise<void> {\n  // this assumes the default Spring Security logout configuration (handler URL)\n  const logoutUrl = options?.logoutUrl ?? 'logout';\n  try {\n    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);\n    await doLogout(logoutUrl, headers);\n  } catch {\n    try {\n      const response = await fetch('?nocache');\n      const responseText = await response.text();\n      const doc = new DOMParser().parseFromString(responseText, 'text/html');\n      const headers = getSpringCsrfTokenHeadersForAuthRequest(doc);\n      await doLogout(logoutUrl, headers);\n    } catch (error) {\n      // clear the token if the call fails\n      clearSpringCsrfMetaTags();\n      throw error;\n    }\n  } finally {\n    CookieManager.remove(JWT_COOKIE_NAME);\n  }\n}\n\n/**\n * It defines what to do when it detects a session is invalid. E.g.,\n * show a login view.\n * It takes an <code>EndpointCallContinue</code> parameter, which can be\n * used to continue the endpoint call.\n */\nexport type OnInvalidSessionCallback = () => Promise<LoginResult>;\n\n/**\n * A helper class for handling invalid sessions during an endpoint call.\n * E.g., you can use this to show user a login page when the session has\n * expired.\n */\nexport class InvalidSessionMiddleware implements MiddlewareClass {\n  private readonly onInvalidSessionCallback: OnInvalidSessionCallback;\n\n  constructor(onInvalidSessionCallback: OnInvalidSessionCallback) {\n    this.onInvalidSessionCallback = onInvalidSessionCallback;\n  }\n\n  async invoke(context: MiddlewareContext, next: MiddlewareNext): Promise<Response> {\n    const clonedContext = { ...context };\n    clonedContext.request = context.request.clone();\n    const response = await next(context);\n    if (response.status === 401) {\n      const loginResult = await this.onInvalidSessionCallback();\n      if (loginResult.token) {\n        clonedContext.request.headers.set(VAADIN_CSRF_HEADER, loginResult.token);\n        return next(clonedContext) as Promise<Response>;\n      }\n    }\n    return response;\n  }\n}\n"],
  "mappings": "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",
  "names": ["CookieManager", "getSpringCsrfInfo", "getSpringCsrfTokenHeadersForAuthRequest", "VAADIN_CSRF_HEADER", "JWT_COOKIE_NAME", "getSpringCsrfTokenFromResponseBody", "body", "doc", "clearSpringCsrfMetaTags", "el", "updateSpringCsrfMetaTags", "springCsrfInfo", "headerNameMeta", "tokenMeta", "getVaadinCsrfTokenFromResponseBody", "match", "updateCsrfTokensBasedOnResponse", "response", "responseText", "token", "springCsrfTokenInfo", "doLogout", "logoutUrl", "headers", "login", "username", "password", "options", "data", "loginProcessingUrl", "result", "savedUrl", "defaultUrl", "vaadinCsrfToken", "springCsrfHeader", "springCsrfToken", "e", "logout", "error", "InvalidSessionMiddleware", "onInvalidSessionCallback", "context", "next", "clonedContext", "loginResult"]
}
