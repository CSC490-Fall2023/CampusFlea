{
  "version": 3,
  "sources": ["src/FluxConnection.ts"],
  "sourcesContent": ["import type { ReactiveControllerHost } from '@lit/reactive-element';\nimport atmosphere from 'atmosphere.js';\nimport type { Subscription } from './Connect.js';\nimport { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';\nimport {\n  isClientMessage,\n  type ServerCloseMessage,\n  type ServerConnectMessage,\n  type ServerMessage,\n} from './FluxMessages.js';\n\nexport enum State {\n  ACTIVE = 'active',\n  INACTIVE = 'inactive',\n}\n\ntype ActiveEvent = CustomEvent<{ active: boolean }>;\ninterface EventMap {\n  'state-changed': ActiveEvent;\n}\n\ntype ListenerType<T extends keyof EventMap> =\n  | ((this: FluxConnection, ev: EventMap[T]) => any)\n  | {\n      handleEvent(ev: EventMap[T]): void;\n    }\n  | null;\n\n/**\n * A representation of the underlying persistent network connection used for subscribing to Flux type endpoint methods.\n */\nexport class FluxConnection extends EventTarget {\n  state: State = State.INACTIVE;\n  readonly #endpointInfos = new Map<string, string>();\n  #nextId = 0;\n  readonly #onCompleteCallbacks = new Map<string, () => void>();\n  readonly #onErrorCallbacks = new Map<string, () => void>();\n  readonly #onNextCallbacks = new Map<string, (value: any) => void>();\n  #pendingMessages: ServerMessage[] = [];\n  #socket?: Atmosphere.Request;\n\n  constructor(connectPrefix: string) {\n    super();\n    this.#connectWebsocket(connectPrefix.replace('/connect', '').replace(/^connect/u, ''));\n  }\n\n  /**\n   * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.\n   *\n   * @param endpointName - the endpoint to connect to\n   * @param methodName - the method in the endpoint to connect to\n   * @param parameters - the parameters to use\n   * @returns a subscription\n   */\n  subscribe(endpointName: string, methodName: string, parameters?: unknown[]): Subscription<any> {\n    const id: string = this.#nextId.toString();\n    this.#nextId += 1;\n    const params = parameters ?? [];\n\n    const msg: ServerConnectMessage = { '@type': 'subscribe', endpointName, id, methodName, params };\n    const endpointInfo = `${endpointName}.${methodName}(${JSON.stringify(params)})`;\n    this.#send(msg);\n    this.#endpointInfos.set(id, endpointInfo);\n    const hillaSubscription: Subscription<any> = {\n      cancel: () => {\n        if (!this.#endpointInfos.has(id)) {\n          // Subscription already closed or canceled\n          return;\n        }\n\n        const closeMessage: ServerCloseMessage = { '@type': 'unsubscribe', id };\n        this.#send(closeMessage);\n        this.#removeSubscription(id);\n      },\n      context(context: ReactiveControllerHost): Subscription<any> {\n        context.addController({\n          hostDisconnected() {\n            hillaSubscription.cancel();\n          },\n        });\n        return hillaSubscription;\n      },\n      onComplete: (callback: () => void): Subscription<any> => {\n        this.#onCompleteCallbacks.set(id, callback);\n        return hillaSubscription;\n      },\n      onError: (callback: () => void): Subscription<any> => {\n        this.#onErrorCallbacks.set(id, callback);\n        return hillaSubscription;\n      },\n      onNext: (callback: (value: any) => void): Subscription<any> => {\n        this.#onNextCallbacks.set(id, callback);\n        return hillaSubscription;\n      },\n    };\n    return hillaSubscription;\n  }\n\n  #connectWebsocket(prefix: string) {\n    const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);\n    this.#socket = atmosphere.subscribe?.({\n      contentType: 'application/json; charset=UTF-8',\n      enableProtocol: true,\n      fallbackTransport: 'long-polling',\n      headers: extraHeaders,\n      maxReconnectOnClose: 10000000,\n      onClose: (_) => {\n        // https://socket.io/docs/v4/client-api/#event-disconnect\n        if (this.state === State.ACTIVE) {\n          this.state = State.INACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: false } }));\n        }\n      },\n      onError: (response) => {\n        // eslint-disable-next-line no-console\n        console.error('error in push communication', response);\n      },\n      onMessage: (response) => {\n        if (response.responseBody) {\n          this.#handleMessage(JSON.parse(response.responseBody));\n        }\n      },\n      onOpen: (_response: any) => {\n        if (this.state === State.INACTIVE) {\n          this.state = State.ACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));\n          this.#sendPendingMessages();\n        }\n      },\n      onReopen: (_response: any) => {\n        if (this.state === State.INACTIVE) {\n          this.state = State.ACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));\n          this.#sendPendingMessages();\n        }\n      },\n      reconnectInterval: 5000,\n      timeout: -1,\n      trackMessageLength: true,\n      transport: 'websocket',\n      url: prefix ? `${prefix}/HILLA/push` : 'HILLA/push',\n    } satisfies Atmosphere.Request);\n  }\n\n  #handleMessage(message: unknown) {\n    if (isClientMessage(message)) {\n      const { id } = message;\n      const endpointInfo = this.#endpointInfos.get(id) ?? 'unknown';\n\n      if (message['@type'] === 'update') {\n        const callback = this.#onNextCallbacks.get(id);\n        if (callback) {\n          callback(message.item);\n        }\n      } else if (message['@type'] === 'complete') {\n        this.#onCompleteCallbacks.get(id)?.();\n        this.#removeSubscription(id);\n      } else {\n        const callback = this.#onErrorCallbacks.get(id);\n        if (callback) {\n          callback();\n        }\n        this.#removeSubscription(id);\n        if (!callback) {\n          throw new Error(`Error in ${endpointInfo}: ${message.message}`);\n        }\n      }\n    } else {\n      throw new Error(`Unknown message from server: ${String(message)}`);\n    }\n  }\n\n  #removeSubscription(id: string) {\n    this.#onNextCallbacks.delete(id);\n    this.#onCompleteCallbacks.delete(id);\n    this.#onErrorCallbacks.delete(id);\n    this.#endpointInfos.delete(id);\n  }\n\n  #send(message: ServerMessage) {\n    if (this.state === State.INACTIVE) {\n      this.#pendingMessages.push(message);\n    } else {\n      this.#socket?.push?.(JSON.stringify(message));\n    }\n  }\n\n  #sendPendingMessages() {\n    this.#pendingMessages.forEach((msg) => this.#send(msg));\n    this.#pendingMessages = [];\n  }\n}\n\nexport interface FluxConnection {\n  addEventListener<T extends keyof EventMap>(type: T, listener: ListenerType<T>): void;\n  removeEventListener<T extends keyof EventMap>(type: T, listener: ListenerType<T>): void;\n}\n"],
  "mappings": "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",
  "names": ["atmosphere", "getCsrfTokenHeadersForEndpointRequest", "isClientMessage", "State", "FluxConnection", "#endpointInfos", "#nextId", "#onCompleteCallbacks", "#onErrorCallbacks", "#onNextCallbacks", "#pendingMessages", "#socket", "connectPrefix", "#connectWebsocket", "endpointName", "methodName", "parameters", "id", "params", "msg", "endpointInfo", "#send", "hillaSubscription", "closeMessage", "#removeSubscription", "context", "callback", "prefix", "extraHeaders", "_", "response", "#handleMessage", "_response", "#sendPendingMessages", "message"]
}
