{
  "version": 3,
  "sources": ["src/Connect.ts"],
  "sourcesContent": ["import type { ReactiveControllerHost } from '@lit/reactive-element';\nimport { ConnectionIndicator, ConnectionState } from '@vaadin/common-frontend';\nimport { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';\nimport {\n  EndpointError,\n  EndpointResponseError,\n  EndpointValidationError,\n  ForbiddenResponseError,\n  UnauthorizedResponseError,\n  type ValidationErrorData,\n} from './EndpointErrors.js';\nimport { FluxConnection } from './FluxConnection.js';\nimport type { VaadinWindow } from './types.js';\n\nconst $wnd = window as VaadinWindow;\n\n$wnd.Vaadin ??= {};\n$wnd.Vaadin.registrations ??= [];\n$wnd.Vaadin.registrations.push({\n  is: 'endpoint',\n});\n\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Represents the connection to and endpoint returning a subscription rather than a value.\n */\nexport interface Subscription<T> {\n  /** Cancels the subscription.  No values are made available after calling this. */\n  cancel(): void;\n\n  /*\n   * Binds to the given context (element) so that when the context is deactivated (element detached), the subscription is closed.\n   */\n  context(context: ReactiveControllerHost): Subscription<T>;\n\n  /** Called when the subscription has completed. No values are made available after calling this. */\n  onComplete(callback: () => void): Subscription<T>;\n\n  /** Called when an exception occured in the subscription. */\n  onError(callback: () => void): Subscription<T>;\n\n  /** Called when a new value is available. */\n  onNext(callback: (value: T) => void): Subscription<T>;\n}\n\ninterface ConnectExceptionData {\n  detail?: any;\n  message: string;\n  type: string;\n  validationErrorData?: ValidationErrorData[];\n}\n\n/**\n * Throws a TypeError if the response is not 200 OK.\n * @param response - The response to assert.\n */\nconst assertResponseIsOk = async (response: Response): Promise<void> => {\n  if (!response.ok) {\n    const errorText = await response.text();\n    let errorJson: ConnectExceptionData | null;\n    try {\n      errorJson = JSON.parse(errorText);\n    } catch (ignored) {\n      // not a json\n      errorJson = null;\n    }\n\n    const message =\n      errorJson?.message ?? errorText.length > 0\n        ? errorText\n        : `expected \"200 OK\" response, but got ${response.status} ${response.statusText}`;\n    const type = errorJson?.type;\n\n    if (errorJson?.validationErrorData) {\n      throw new EndpointValidationError(message, errorJson.validationErrorData, type);\n    }\n\n    if (type) {\n      throw new EndpointError(message, type, errorJson?.detail);\n    }\n\n    switch (response.status) {\n      case 401:\n        throw new UnauthorizedResponseError(message, response);\n      case 403:\n        throw new ForbiddenResponseError(message, response);\n      default:\n        throw new EndpointResponseError(message, response);\n    }\n  }\n};\n\n/**\n * The `ConnectClient` constructor options.\n */\nexport interface ConnectClientOptions {\n  /**\n   * The `middlewares` property value.\n   */\n  middlewares?: Middleware[];\n  /**\n   * The `prefix` property value.\n   */\n  prefix?: string;\n}\n\nexport interface EndpointCallMetaInfo {\n  /**\n   * The endpoint name.\n   */\n  endpoint: string;\n\n  /**\n   * The method name to call on in the endpoint class.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments.\n   */\n  params?: Record<string, unknown>;\n}\n\n/**\n * An object with the call arguments and the related Request instance.\n * See also {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface MiddlewareContext extends EndpointCallMetaInfo {\n  /**\n   * The Fetch API Request object reflecting the other properties.\n   */\n  request: Request;\n}\n\n/**\n * An async middleware callback that invokes the next middleware in the chain\n * or makes the actual request.\n * @param context - The information about the call and request\n */\nexport type MiddlewareNext = (context: MiddlewareContext) => MaybePromise<Response>;\n\n/**\n * An interface that allows defining a middleware as a class.\n */\nexport interface MiddlewareClass {\n  /**\n   * @param context - The information about the call and request\n   * @param next - Invokes the next in the call chain\n   */\n  invoke(context: MiddlewareContext, next: MiddlewareNext): MaybePromise<Response>;\n}\n\n/**\n * An async callback function that can intercept the request and response\n * of a call.\n */\nexport type MiddlewareFunction = (context: MiddlewareContext, next: MiddlewareNext) => MaybePromise<Response>;\n\n/**\n * An async callback that can intercept the request and response\n * of a call, could be either a function or a class.\n */\nexport type Middleware = MiddlewareClass | MiddlewareFunction;\n\nfunction isFlowLoaded(): boolean {\n  return $wnd.Vaadin?.Flow?.clients?.TypeScript !== undefined;\n}\n\n/**\n * A list of parameters supported by {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface EndpointRequestInit {\n  /**\n   * An AbortSignal to set request's signal.\n   */\n  signal?: AbortSignal | null;\n}\n\n/**\n * A low-level network calling utility. It stores\n * a prefix and facilitates remote calls to endpoint class methods\n * on the Hilla backend.\n *\n * Example usage:\n *\n * ```js\n * const client = new ConnectClient();\n * const responseData = await client.call('MyEndpoint', 'myMethod');\n * ```\n *\n * ### Prefix\n *\n * The client supports an `prefix` constructor option:\n * ```js\n * const client = new ConnectClient({prefix: '/my-connect-prefix'});\n * ```\n *\n * The default prefix is '/connect'.\n *\n */\nexport class ConnectClient {\n  /**\n   * The array of middlewares that are invoked during a call.\n   */\n  middlewares: Middleware[] = [];\n  /**\n   * The Hilla endpoint prefix\n   */\n  prefix = '/connect';\n\n  #fluxConnection?: FluxConnection;\n\n  /**\n   * @param options - Constructor options.\n   */\n  constructor(options: ConnectClientOptions = {}) {\n    if (options.prefix) {\n      this.prefix = options.prefix;\n    }\n\n    if (options.middlewares) {\n      this.middlewares = options.middlewares;\n    }\n\n    // add connection indicator to DOM\n    ConnectionIndicator.create();\n\n    // Listen to browser online/offline events and update the loading indicator accordingly.\n    // Note: if Flow.ts is loaded, it instead handles the state transitions.\n    addEventListener('online', () => {\n      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;\n      }\n    });\n    addEventListener('offline', () => {\n      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;\n      }\n    });\n  }\n\n  /**\n   * Gets a representation of the underlying persistent network connection used for subscribing to Flux type endpoint\n   * methods.\n   */\n  get fluxConnection(): FluxConnection {\n    if (!this.#fluxConnection) {\n      this.#fluxConnection = new FluxConnection(this.prefix);\n    }\n    return this.#fluxConnection;\n  }\n\n  /**\n   * Calls the given endpoint method defined using the endpoint and method\n   * parameters with the parameters given as params.\n   * Asynchronously returns the parsed JSON response data.\n   *\n   * @param endpoint - Endpoint name.\n   * @param method - Method name to call in the endpoint class.\n   * @param params - Optional parameters to pass to the method.\n   * @param init - Optional parameters for the request\n   * @returns Decoded JSON response data.\n   */\n  async call(\n    endpoint: string,\n    method: string,\n    params?: Record<string, unknown>,\n    init?: EndpointRequestInit,\n  ): Promise<any> {\n    if (arguments.length < 2) {\n      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);\n    }\n\n    const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);\n    const headers: Record<string, string> = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...csrfHeaders,\n    };\n\n    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {\n      body:\n        params !== undefined ? JSON.stringify(params, (_, value) => (value === undefined ? null : value)) : undefined,\n      headers,\n      method: 'POST',\n    });\n\n    // The middleware `context`, includes the call arguments and the request\n    // constructed from them\n    const initialContext: MiddlewareContext = {\n      endpoint,\n      method,\n      params,\n      request,\n    };\n\n    // The internal middleware to assert and parse the response. The internal\n    // response handling should come last after the other middlewares are done\n    // with processing the response. That is why this middleware is first\n    // in the final middlewares array.\n    async function responseHandlerMiddleware(context: MiddlewareContext, next: MiddlewareNext): Promise<Response> {\n      const response = await next(context);\n      await assertResponseIsOk(response);\n      const text = await response.text();\n      return JSON.parse(text, (_, value: any) => (value === null ? undefined : value));\n    }\n\n    // The actual fetch call itself is expressed as a middleware\n    // chain item for our convenience. Always having an ending of the chain\n    // this way makes the folding down below more concise.\n    async function fetchNext(context: MiddlewareContext) {\n      $wnd.Vaadin?.connectionState?.loadingStarted();\n      try {\n        const response = await fetch(context.request, { signal: init?.signal });\n        $wnd.Vaadin?.connectionState?.loadingFinished();\n        return response;\n      } catch (error: unknown) {\n        // don't bother about connections aborted by purpose\n        if (error instanceof Error && error.name === 'AbortError') {\n          $wnd.Vaadin?.connectionState?.loadingFinished();\n        } else {\n          $wnd.Vaadin?.connectionState?.loadingFailed();\n        }\n        return Promise.reject(error);\n      }\n    }\n\n    // Assemble the final middlewares array from internal\n    // and external middlewares\n    const middlewares = [responseHandlerMiddleware as Middleware, ...this.middlewares];\n\n    // Fold the final middlewares array into a single function\n    const chain = middlewares.reduceRight(\n      (next: MiddlewareNext, middleware) =>\n        // Compose and return the new chain step, that takes the context and\n        // invokes the current middleware with the context and the further chain\n        // as the next argument\n        async (context) => {\n          if (typeof middleware === 'function') {\n            return middleware(context, next);\n          }\n          return middleware.invoke(context, next);\n        },\n      // Initialize reduceRight the accumulator with `fetchNext`\n      fetchNext,\n    );\n\n    // Invoke all the folded async middlewares and return\n    return chain(initialContext);\n  }\n\n  /**\n   * Subscribes to the given method defined using the endpoint and method\n   * parameters with the parameters given as params. The method must return a\n   * compatible type such as a Flux.\n   * Returns a subscription that is used to fetch values as they become available.\n   *\n   * @param endpoint - Endpoint name.\n   * @param method - Method name to call in the endpoint class.\n   * @param params - Optional parameters to pass to the method.\n   * @returns A subscription used to handles values as they become available.\n   */\n  subscribe(endpoint: string, method: string, params?: any): Subscription<any> {\n    return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);\n  }\n}\n"],
  "mappings": "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",
  "names": ["ConnectionIndicator", "ConnectionState", "getCsrfTokenHeadersForEndpointRequest", "EndpointError", "EndpointResponseError", "EndpointValidationError", "ForbiddenResponseError", "UnauthorizedResponseError", "FluxConnection", "$wnd", "assertResponseIsOk", "response", "errorText", "errorJson", "message", "type", "isFlowLoaded", "ConnectClient", "#fluxConnection", "options", "endpoint", "method", "params", "init", "headers", "request", "_", "value", "initialContext", "responseHandlerMiddleware", "context", "next", "text", "fetchNext", "error", "middleware"]
}
