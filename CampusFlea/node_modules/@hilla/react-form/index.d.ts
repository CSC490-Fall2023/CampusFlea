import { type AbstractModel, type BinderConfiguration, type ModelConstructor, type Validator, type ValueError } from '@hilla/form';
export type FieldDirectiveResult = Readonly<{
    name: string;
    onBlur(): void;
    onChange(): void;
    onInput(): void;
    ref(element: HTMLElement | null): void;
}>;
export type FieldDirective = (model: AbstractModel<any>) => FieldDirectiveResult;
export type UseFormPartResult<T, M extends AbstractModel<T>> = Readonly<{
    defaultValue: T;
    dirty: boolean;
    errors: ReadonlyArray<ValueError<unknown>>;
    invalid: boolean;
    model: M;
    name: string;
    field: FieldDirective;
    ownErrors: ReadonlyArray<ValueError<T>>;
    required: boolean;
    validators: ReadonlyArray<Validator<T>>;
    value?: T;
    visited: boolean;
    addValidator(validator: Validator<T>): void;
    setValidators(validators: ReadonlyArray<Validator<T>>): void;
    setValue(value: T | undefined): void;
    setVisited(visited: boolean): void;
    validate(): Promise<ReadonlyArray<ValueError<unknown>>>;
}>;
export type UseFormResult<T, M extends AbstractModel<T>> = Readonly<{
    value: T;
    setDefaultValue(value: T): void;
    setValue(value: T): void;
    submit(): Promise<T | undefined>;
    reset(): void;
    clear(): void;
    read(value: T | undefined | null): void;
}> & UseFormPartResult<T, M>;
export declare function useForm<T, M extends AbstractModel<T>>(Model: ModelConstructor<T, M>, config?: BinderConfiguration<T>): UseFormResult<T, M>;
export declare function useFormPart<M extends AbstractModel<any>>(model: M): UseFormPartResult<ReturnType<M['valueOf']>, M>;
//# sourceMappingURL=index.d.ts.map