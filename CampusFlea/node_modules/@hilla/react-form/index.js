import { _fromString, _validity, BinderRoot, CHANGED, defaultValidity, getBinderNode, getDefaultFieldStrategy, hasFromString, isFieldElement, } from '@hilla/form';
import { useEffect, useMemo, useReducer, useRef } from 'react';
const $wnd = window;
$wnd.Vaadin ??= {};
$wnd.Vaadin.registrations ??= [];
$wnd.Vaadin.registrations.push({
    is: '@hilla/react-form',
    version: /* updated-by-script */ '2.2.0',
});
function useUpdate() {
    const [_, update] = useReducer((x) => ++x, 0);
    return update;
}
function convertFieldValue(model, fieldValue) {
    return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
function getFormPart(node) {
    return {
        addValidator: node.addValidator.bind(node),
        defaultValue: node.defaultValue,
        dirty: node.dirty,
        errors: node.errors,
        invalid: node.invalid,
        model: node.model,
        name: node.name,
        ownErrors: node.ownErrors,
        required: node.required,
        setValidators(validators) {
            node.validators = validators;
        },
        setValue(value) {
            node.value = value;
        },
        setVisited(visited) {
            node.visited = visited;
        },
        validate: node.validate.bind(node),
        validators: node.validators,
        value: node.value,
        visited: node.visited,
    };
}
function useFields(node) {
    return useMemo(() => {
        const registry = new WeakMap();
        return ((model) => {
            const n = getBinderNode(model);
            n.initializeValue(true);
            const fieldState = registry.get(model) ?? {
                element: undefined,
                errorMessage: '',
                invalid: false,
                markVisited: () => {
                    n.visited = true;
                },
                ref(element) {
                    if (!element) {
                        fieldState.element?.removeEventListener('change', fieldState.updateValue);
                        fieldState.element?.removeEventListener('input', fieldState.updateValue);
                        fieldState.element?.removeEventListener('blur', fieldState.markVisited);
                        fieldState.strategy?.removeEventListeners();
                        fieldState.element = undefined;
                        fieldState.strategy = undefined;
                        return;
                    }
                    if (!isFieldElement(element)) {
                        throw new TypeError(`Element '${element.localName}' is not a form element`);
                    }
                    if (fieldState.element !== element) {
                        fieldState.element = element;
                        fieldState.element.addEventListener('change', fieldState.updateValue);
                        fieldState.element.addEventListener('input', fieldState.updateValue);
                        fieldState.element.addEventListener('blur', fieldState.markVisited);
                        fieldState.strategy = getDefaultFieldStrategy(element, model);
                    }
                },
                required: false,
                strategy: undefined,
                updateValue: () => {
                    if (fieldState.strategy) {
                        // Remove invalid flag, so that .checkValidity() in Vaadin Components
                        // does not interfere with errors from Hilla.
                        fieldState.strategy.invalid = false;
                        // When bad input is detected, skip reading new value in binder state
                        fieldState.strategy.checkValidity();
                        if (!fieldState.strategy.validity.badInput) {
                            fieldState.value = fieldState.strategy.value;
                        }
                        n[_validity] = fieldState.strategy.validity;
                        n.value = convertFieldValue(model, fieldState.value);
                    }
                },
                value: undefined,
            };
            if (!registry.has(model)) {
                registry.set(model, fieldState);
            }
            if (fieldState.strategy) {
                const valueFromField = convertFieldValue(model, fieldState.value);
                if (valueFromField !== n.value && !(Number.isNaN(n.value) && Number.isNaN(valueFromField))) {
                    fieldState.value = n.value;
                    fieldState.strategy.value = n.value;
                }
                if (fieldState.required !== n.required) {
                    fieldState.required = n.required;
                    fieldState.strategy.required = n.required;
                }
                const firstError = n.ownErrors.at(0);
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                const errorMessage = firstError?.message ?? '';
                if (fieldState.errorMessage !== errorMessage) {
                    fieldState.errorMessage = errorMessage;
                    fieldState.strategy.errorMessage = errorMessage;
                }
                // Make sure invalid state is always in sync
                fieldState.invalid = n.invalid;
                fieldState.strategy.invalid = n.invalid;
            }
            return {
                name: n.name,
                ref: fieldState.ref,
            };
        });
    }, [node]);
}
export function useForm(Model, config) {
    const configRef = useRef({});
    configRef.current.onSubmit = config?.onSubmit;
    configRef.current.onChange = config?.onChange;
    const update = useUpdate();
    const binder = useMemo(() => new BinderRoot(Model, configRef.current), [Model]);
    const field = useFields(binder);
    useEffect(() => {
        binder.addEventListener(CHANGED.type, update);
    }, [binder]);
    return {
        ...getFormPart(binder),
        clear: binder.clear.bind(binder),
        field,
        read: binder.read.bind(binder),
        reset: binder.reset.bind(binder),
        setDefaultValue: (defaultValue) => {
            binder.defaultValue = defaultValue;
        },
        setValue: (value) => {
            binder.value = value;
        },
        submit: binder.submit.bind(binder),
        value: binder.value,
    };
}
export function useFormPart(model) {
    const binderNode = getBinderNode(model);
    const field = useFields(binderNode);
    return {
        ...getFormPart(binderNode),
        field,
    };
}
//# sourceMappingURL=index.js.map