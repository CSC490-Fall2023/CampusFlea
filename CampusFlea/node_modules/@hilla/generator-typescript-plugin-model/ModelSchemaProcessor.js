import { convertReferenceSchemaToPath, convertReferenceSchemaToSpecifier, decomposeSchema, isArraySchema, isBooleanSchema, isComposedSchema, isIntegerSchema, isMapSchema, isNullableSchema, isNumberSchema, isReferenceSchema, isStringSchema, } from '@hilla/generator-typescript-core/Schema.js';
import ts, {} from 'typescript';
import { AnnotationParser, isAnnotatedSchema, isValidationConstrainedSchema, } from './annotation.js';
import { importBuiltInFormModel } from './utils.js';
const $dependencies = Symbol();
const $processArray = Symbol();
const $processRecord = Symbol();
const $processReference = Symbol();
const $processString = Symbol();
const $processNumber = Symbol();
const $processBoolean = Symbol();
const $processUnknown = Symbol();
const $originalSchema = Symbol();
const $schema = Symbol();
export class ModelSchemaPartProcessor {
    [$dependencies];
    [$originalSchema];
    [$schema];
    constructor(schema, dependencies) {
        this[$dependencies] = dependencies;
        this[$originalSchema] = schema;
        this[$schema] = isComposedSchema(schema) ? decomposeSchema(schema)[0] : schema;
    }
    process() {
        const schema = this[$schema];
        if (isReferenceSchema(schema)) {
            return this[$processReference](schema);
        }
        if (isArraySchema(schema)) {
            return this[$processArray](schema);
        }
        if (isMapSchema(schema)) {
            return this[$processRecord](schema);
        }
        if (isStringSchema(schema)) {
            return this[$processString](schema);
        }
        if (isNumberSchema(schema) || isIntegerSchema(schema)) {
            return this[$processNumber](schema);
        }
        if (isBooleanSchema(schema)) {
            return this[$processBoolean](schema);
        }
        return this[$processUnknown](schema);
    }
}
class ModelSchemaInternalTypeProcessor extends ModelSchemaPartProcessor {
    [$processArray](schema) {
        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('ReadonlyArray'), [
            new ModelSchemaInternalTypeProcessor(schema.items, this[$dependencies]).process(),
        ]);
    }
    [$processBoolean](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
    }
    [$processNumber](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
    }
    [$processRecord]({ additionalProperties: props }) {
        const valueType = typeof props === 'boolean'
            ? ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)
            : new ModelSchemaInternalTypeProcessor(props, this[$dependencies]).process();
        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('Record'), [
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
            valueType,
        ]);
    }
    [$processReference](schema) {
        const { paths, imports } = this[$dependencies];
        const typeName = convertReferenceSchemaToSpecifier(schema);
        const typePath = paths.createRelativePath(convertReferenceSchemaToPath(schema));
        return ts.factory.createTypeReferenceNode(imports.default.getIdentifier(typePath) ?? imports.default.add(typePath, typeName, true));
    }
    [$processString](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
    }
    [$processUnknown](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
    }
}
class ModelSchemaIdentifierProcessor extends ModelSchemaPartProcessor {
    [$processArray](_) {
        return importBuiltInFormModel('ArrayModel', this[$dependencies]);
    }
    [$processBoolean](_) {
        return importBuiltInFormModel('BooleanModel', this[$dependencies]);
    }
    [$processNumber](_) {
        return importBuiltInFormModel('NumberModel', this[$dependencies]);
    }
    [$processRecord](_) {
        return importBuiltInFormModel('ObjectModel', this[$dependencies]);
    }
    [$processReference](schema) {
        const { paths, imports } = this[$dependencies];
        const name = `${convertReferenceSchemaToSpecifier(schema)}Model`;
        const path = paths.createRelativePath(`${convertReferenceSchemaToPath(schema)}Model`);
        return imports.default.getIdentifier(path) ?? imports.default.add(path, name);
    }
    [$processString](_) {
        return importBuiltInFormModel('StringModel', this[$dependencies]);
    }
    [$processUnknown](_) {
        return importBuiltInFormModel('ObjectModel', this[$dependencies]);
    }
}
export class ModelSchemaTypeProcessor extends ModelSchemaPartProcessor {
    #id;
    constructor(schema, dependencies) {
        super(schema, dependencies);
        this.#id = new ModelSchemaIdentifierProcessor(schema, dependencies);
    }
    [$processArray](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processArray](schema), [
            new ModelSchemaInternalTypeProcessor(schema.items, this[$dependencies]).process(),
            new ModelSchemaTypeProcessor(schema.items, this[$dependencies]).process(),
        ]);
    }
    [$processBoolean](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processBoolean](schema));
    }
    [$processNumber](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processNumber](schema));
    }
    [$processRecord](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processRecord](schema), [
            new ModelSchemaInternalTypeProcessor(schema, this[$dependencies]).process(),
        ]);
    }
    [$processReference](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processReference](schema));
    }
    [$processString](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processString](schema));
    }
    [$processUnknown](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processUnknown](schema), [
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
        ]);
    }
}
export class ModelSchemaExpressionProcessor extends ModelSchemaPartProcessor {
    #parse;
    constructor(schema, dependencies) {
        super(schema, dependencies);
        const parser = new AnnotationParser((name) => importBuiltInFormModel(name, dependencies));
        this.#parse = parser.parse.bind(parser);
    }
    process() {
        const schema = this[$schema];
        let result = super.process();
        if (isAnnotatedSchema(schema)) {
            result = [...result, ...this.#getValidatorsFromAnnotations(schema)];
        }
        if (isValidationConstrainedSchema(schema)) {
            result = [...result, ...this.#getValidatorsFromValidationConstraints(schema)];
        }
        return [isNullableSchema(this[$originalSchema]) ? ts.factory.createTrue() : ts.factory.createFalse(), ...result];
    }
    [$processArray](schema) {
        return [
            new ModelSchemaIdentifierProcessor(schema.items, this[$dependencies]).process(),
            ts.factory.createArrayLiteralExpression(new ModelSchemaExpressionProcessor(schema.items, this[$dependencies]).process()),
        ];
    }
    [$processBoolean](_) {
        return [];
    }
    [$processNumber](_) {
        return [];
    }
    [$processRecord](_) {
        return [];
    }
    [$processReference](_) {
        return [];
    }
    [$processString](_) {
        return [];
    }
    [$processUnknown](_) {
        return [];
    }
    #getValidatorsFromAnnotations(schema) {
        return schema['x-annotations'].map(this.#parse);
    }
    #getValidatorsFromValidationConstraints(schema) {
        return schema['x-validation-constraints'].map(this.#parse);
    }
}
//# sourceMappingURL=ModelSchemaProcessor.js.map