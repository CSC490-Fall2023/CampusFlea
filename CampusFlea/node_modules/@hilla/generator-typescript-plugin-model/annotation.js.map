{"version":3,"file":"annotation.js","sourceRoot":"","sources":["src/annotation.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,0BAA0B,GAG3B,MAAM,4CAA4C,CAAC;AACpD,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,0CAA0C,CAAC;AAC/E,OAAO,EAAE,EAAE,EAMV,MAAM,YAAY,CAAC;AAMpB,MAAM,UAAU,iBAAiB,CAAC,MAAc;IAC9C,OAAO,0BAA0B,CAAC,MAAM,CAAC,IAAI,eAAe,IAAI,MAAM,CAAC;AACzE,CAAC;AAED,MAAM,UAAU,6BAA6B,CAAC,MAAc;IAC1D,OAAO,0BAA0B,CAAC,MAAM,CAAC,IAAI,0BAA0B,IAAI,MAAM,CAAC;AACpF,CAAC;AASD,SAAS,QAAQ,CAAuB,CAAC,SAAS,CAAuB;IACvE,OAAQ,SAA+B,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAgB,CAAC;AAC3F,CAAC;AAED,MAAM,oBAAoB,GAAG,SAAS,CAAC;AAEvC,MAAM,OAAO,gBAAgB;IAClB,SAAS,CAAqB;IAEvC,YAAY,QAA4B;QACtC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,KAAK,CAAC,UAA+B;QACnC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAClC,MAAM,YAAY,GAAG,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAC7C,MAAM,UAAU,GAAG,YAAY,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;YACtF,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;YAEtC,OAAO,QAAQ,CAAgB,GAAG,oBAAoB,UAAU,UAAU,EAAE,EAAE,QAAQ,EAAE;gBACtF,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;aACrF,CAAC,CAAC;SACJ;QAED,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CACnC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,EACrC,SAAS,EACT,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CACtF,CAAC;IACJ,CAAC;IAED,0BAA0B,CAAC,UAAmC;QAC5D,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACtC,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;QAE1G,OAAO,QAAQ,CAAC,GAAG,oBAAoB,IAAI,GAAG,EAAE,EAAE,QAAQ,EAAE;YAC1D,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,CACjB,EAAE,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC5D,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC;gBACvE,CAAC,CAAC,IAAI,CACT;SACF,CAAC,CAAC;IACL,CAAC;CACF","sourcesContent":["import {\n  isNonComposedRegularSchema,\n  type NonComposedRegularSchema,\n  type Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport { template, transform } from '@hilla/generator-typescript-utils/ast.js';\nimport ts, {\n  type Expression,\n  type Identifier,\n  type NewExpression,\n  type Statement,\n  type VariableStatement,\n} from 'typescript';\n\nexport type AnnotatedSchema = NonComposedRegularSchema & Readonly<{ 'x-annotations': readonly string[] }>;\nexport type ValidationConstrainedSchema = NonComposedRegularSchema &\n  Readonly<{ 'x-validation-constraints': readonly Annotation[] }>;\n\nexport function isAnnotatedSchema(schema: Schema): schema is AnnotatedSchema {\n  return isNonComposedRegularSchema(schema) && 'x-annotations' in schema;\n}\n\nexport function isValidationConstrainedSchema(schema: Schema): schema is ValidationConstrainedSchema {\n  return isNonComposedRegularSchema(schema) && 'x-validation-constraints' in schema;\n}\n\nexport interface Annotation {\n  simpleName: string;\n  attributes?: Record<string, unknown>;\n}\n\nexport type AnnotationImporter = (name: string) => Identifier;\n\nfunction selector<T extends Expression>([statement]: readonly Statement[]): T {\n  return (statement as VariableStatement).declarationList.declarations[0].initializer as T;\n}\n\nconst variableStatementVar = 'const a';\n\nexport class AnnotationParser {\n  readonly #importer: AnnotationImporter;\n\n  constructor(importer: AnnotationImporter) {\n    this.#importer = importer;\n  }\n\n  parse(annotation: Annotation | string): ts.NewExpression {\n    if (typeof annotation === 'string') {\n      const nameEndIndex = annotation.indexOf('(');\n      const simpleName = nameEndIndex >= 0 ? annotation.slice(0, nameEndIndex) : annotation;\n      const id = this.#importer(simpleName);\n\n      return template<NewExpression>(`${variableStatementVar} = new ${annotation}`, selector, [\n        transform((node) => (ts.isIdentifier(node) && node.text === simpleName ? id : node)),\n      ]);\n    }\n\n    return ts.factory.createNewExpression(\n      this.#importer(annotation.simpleName),\n      undefined,\n      annotation.attributes ? [this.#parseAnnotationAttributes(annotation.attributes)] : [],\n    );\n  }\n\n  #parseAnnotationAttributes(attributes: Record<string, unknown>): Expression {\n    const names = Object.keys(attributes);\n    const tpl = JSON.stringify(names.includes('value') && names.length === 1 ? attributes.value : attributes);\n\n    return template(`${variableStatementVar}=${tpl}`, selector, [\n      transform((node) =>\n        ts.isPropertyAssignment(node) && ts.isStringLiteral(node.name)\n          ? ts.factory.createPropertyAssignment(node.name.text, node.initializer)\n          : node,\n      ),\n    ]);\n  }\n}\n"]}