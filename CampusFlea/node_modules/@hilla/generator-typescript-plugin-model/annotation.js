import { isNonComposedRegularSchema, } from '@hilla/generator-typescript-core/Schema.js';
import { template, transform } from '@hilla/generator-typescript-utils/ast.js';
import ts, {} from 'typescript';
export function isAnnotatedSchema(schema) {
    return isNonComposedRegularSchema(schema) && 'x-annotations' in schema;
}
export function isValidationConstrainedSchema(schema) {
    return isNonComposedRegularSchema(schema) && 'x-validation-constraints' in schema;
}
function selector([statement]) {
    return statement.declarationList.declarations[0].initializer;
}
const variableStatementVar = 'const a';
export class AnnotationParser {
    #importer;
    constructor(importer) {
        this.#importer = importer;
    }
    parse(annotation) {
        if (typeof annotation === 'string') {
            const nameEndIndex = annotation.indexOf('(');
            const simpleName = nameEndIndex >= 0 ? annotation.slice(0, nameEndIndex) : annotation;
            const id = this.#importer(simpleName);
            return template(`${variableStatementVar} = new ${annotation}`, selector, [
                transform((node) => (ts.isIdentifier(node) && node.text === simpleName ? id : node)),
            ]);
        }
        return ts.factory.createNewExpression(this.#importer(annotation.simpleName), undefined, annotation.attributes ? [this.#parseAnnotationAttributes(annotation.attributes)] : []);
    }
    #parseAnnotationAttributes(attributes) {
        const names = Object.keys(attributes);
        const tpl = JSON.stringify(names.includes('value') && names.length === 1 ? attributes.value : attributes);
        return template(`${variableStatementVar}=${tpl}`, selector, [
            transform((node) => ts.isPropertyAssignment(node) && ts.isStringLiteral(node.name)
                ? ts.factory.createPropertyAssignment(node.name.text, node.initializer)
                : node),
        ]);
    }
}
//# sourceMappingURL=annotation.js.map