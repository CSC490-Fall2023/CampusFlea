{
  "version": 3,
  "sources": ["src/BinderRoot.ts"],
  "sourcesContent": ["import { EndpointValidationError, type ValidationErrorData } from '@hilla/frontend/EndpointErrors.js';\nimport { BinderNode, CHANGED } from './BinderNode.js';\nimport { type FieldStrategy, getDefaultFieldStrategy } from './Field.js';\nimport { _parent, type AbstractModel, type HasValue, type ModelConstructor } from './Models.js';\nimport {\n  type InterpolateMessageCallback,\n  runValidator,\n  ServerValidator,\n  ValidationError,\n  type Validator,\n  type ValueError,\n} from './Validation.js';\n\nexport { CHANGED };\n\nconst _submitting = Symbol('submitting');\nconst _defaultValue = Symbol('defaultValue');\nconst _value = Symbol('value');\nconst _emptyValue = Symbol('emptyValue');\nconst _config = Symbol('config');\nconst _validations = Symbol('validations');\nconst _validating = Symbol('validating');\nconst _validationRequestSymbol = Symbol('validationRequest');\n\nexport type BinderConfiguration<T> = Readonly<{\n  onChange?(oldValue?: T): void;\n  onSubmit?(value: T): Promise<T | undefined> | Promise<void>;\n}>;\n\nexport type BinderRootConfiguration<T> = BinderConfiguration<T> &\n  Readonly<{\n    context?: any;\n  }>;\n\n/**\n * A simplified Binder that does not require a context.\n * It can be used as root when there is no Element to use as context.\n *\n * @typeParam T - Type of the value that binds to a form\n * @typeParam M - Type of the model that describes the structure of the value\n */\nexport class BinderRoot<T, M extends AbstractModel<T>> extends BinderNode<T, M> {\n  static interpolateMessageCallback?: InterpolateMessageCallback<any>;\n\n  private [_defaultValue]!: T; // Initialized in the `read()` method\n\n  private [_value]!: T; // Initialized in the `read()` method\n\n  private [_emptyValue]: T;\n\n  private [_submitting] = false;\n\n  private [_validating] = false;\n\n  private [_validationRequestSymbol]?: Promise<void>;\n\n  private [_config]?: BinderRootConfiguration<T>;\n\n  private [_validations] = new Map<AbstractModel<any>, Map<Validator<any>, Promise<ReadonlyArray<ValueError<any>>>>>();\n\n  #context: any = this;\n\n  /**\n   *\n   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model\n   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.\n   *\n   * ```\n   * binder = new BinderRoot(OrderModel);\n   * or\n   * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});\n   * ```\n   */\n  constructor(Model: ModelConstructor<T, M>, config?: BinderRootConfiguration<T>) {\n    const valueContainer: HasValue<T> = { value: undefined };\n    super(new Model(valueContainer, 'value', false));\n    this[_emptyValue] = valueContainer.value!;\n    // @ts-expect-error the model's parent is the binder\n    this.model[_parent] = this;\n    this.#context = config?.context ?? this;\n    this[_config] = config;\n    this.read(this[_emptyValue]);\n  }\n\n  /**\n   * The initial value of the form, before any fields are edited by the user.\n   */\n  override get defaultValue(): T {\n    return this[_defaultValue];\n  }\n\n  override set defaultValue(newValue: T) {\n    this[_defaultValue] = newValue;\n    this.dispatchEvent(CHANGED);\n  }\n\n  /**\n   * The current value of the form.\n   */\n  override get value(): T {\n    return this[_value];\n  }\n\n  override set value(newValue: T) {\n    if (newValue === this[_value]) {\n      return;\n    }\n\n    const oldValue = this[_value];\n    this[_value] = newValue;\n    this.update(oldValue);\n    this.updateValidation().catch(() => {});\n  }\n\n  /**\n   * Indicates the submitting status of the form.\n   * True if the form was submitted, but the submit promise is not resolved yet.\n   */\n  get submitting(): boolean {\n    return this[_submitting];\n  }\n\n  /**\n   * Indicates the validating status of the form.\n   * True when there is an ongoing validation.\n   */\n  get validating(): boolean {\n    return this[_validating];\n  }\n\n  /**\n   * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.\n   *\n   * @param value - The value to read, or undefined to clear.\n   */\n  read(value: T | null | undefined): void {\n    if (value === undefined || value === null) {\n      this.clear();\n      return;\n    }\n    this.defaultValue = value;\n    if (\n      // Skip when no value is set yet (e.g., invoked from constructor)\n      this.value &&\n      // Clear validation state, then proceed if update is needed\n      this.clearValidation() &&\n      // When value is dirty, another update is coming from invoking the value\n      // setter below, so we skip this one to prevent duplicate updates\n      this.value === value\n    ) {\n      this.update(this.value);\n    }\n\n    this.value = this.defaultValue;\n  }\n\n  /**\n   * Reset the form to the previous value\n   */\n  reset(): void {\n    this.read(this[_defaultValue]);\n  }\n\n  /**\n   * Sets the form to empty value, as defined in the Model.\n   */\n  clear(): void {\n    this.read(this[_emptyValue]);\n  }\n\n  /**\n   * Submit the current form value to a predefined\n   * onSubmit callback.\n   *\n   * It's a no-op if the onSubmit callback is undefined.\n   */\n  async submit(): Promise<T | undefined> {\n    const onSubmit = this[_config]?.onSubmit;\n    if (onSubmit) {\n      return this.submitTo(onSubmit as (value: T) => Promise<any>);\n    }\n    return undefined;\n  }\n\n  /**\n   * Submit the current form value to callback\n   *\n   * @param endpointMethod - the callback function\n   */\n  async submitTo<V>(endpointMethod: (value: T) => Promise<V>): Promise<V> {\n    const errors = await this.validate();\n    if (errors.length) {\n      throw new ValidationError(errors);\n    }\n\n    this[_submitting] = true;\n    this.update(this.value);\n    this.dispatchEvent(CHANGED);\n    try {\n      return await endpointMethod.call(this.#context, this.value);\n    } catch (error: unknown) {\n      if (error instanceof EndpointValidationError && error.validationErrorData.length) {\n        const valueErrors: Array<ValueError<any>> = [];\n        error.validationErrorData.forEach((data: ValidationErrorData) => {\n          const res =\n            /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(\n              data.message,\n            );\n          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? '', undefined, data.message];\n          valueErrors.push({\n            message,\n            property,\n            validator: new ServerValidator(message),\n            value,\n          });\n        });\n        this.setErrorsWithDescendants(valueErrors);\n        throw new ValidationError(valueErrors);\n      }\n\n      throw error;\n    } finally {\n      this[_submitting] = false;\n      this.defaultValue = this.value;\n      this.update(this.value);\n    }\n  }\n\n  async requestValidation<NT, NM extends AbstractModel<NT>>(\n    model: NM,\n    validator: Validator<NT>,\n  ): Promise<ReadonlyArray<ValueError<NT>>> {\n    let modelValidations: Map<Validator<NT>, Promise<ReadonlyArray<ValueError<NT>>>>;\n    if (this[_validations].has(model)) {\n      modelValidations = this[_validations].get(model) as Map<Validator<NT>, Promise<ReadonlyArray<ValueError<NT>>>>;\n    } else {\n      modelValidations = new Map();\n      this[_validations].set(model, modelValidations);\n    }\n\n    await this.performValidation();\n\n    if (modelValidations.has(validator)) {\n      return modelValidations.get(validator)!;\n    }\n\n    const promise = runValidator(model, validator, BinderRoot.interpolateMessageCallback);\n    modelValidations.set(validator, promise);\n    const valueErrors = await promise;\n\n    modelValidations.delete(validator);\n    if (modelValidations.size === 0) {\n      this[_validations].delete(model);\n    }\n    if (this[_validations].size === 0) {\n      this.completeValidation();\n    }\n\n    return valueErrors;\n  }\n\n  /**\n   * Determines and returns the field directive strategy for the bound element.\n   * Override to customise the binding strategy for a component.\n   * The Binder extends BinderNode, see the inherited properties and methods below.\n   *\n   * @param elm - the bound element\n   * @param model - the bound model\n   */\n  getFieldStrategy<TField>(elm: any, model?: AbstractModel<TField>): FieldStrategy {\n    return getDefaultFieldStrategy(elm, model);\n  }\n\n  protected performValidation(): Promise<void> | void {\n    if (!this[_validationRequestSymbol]) {\n      this[_validating] = true;\n      this.dispatchEvent(CHANGED);\n      this[_validationRequestSymbol] = Promise.resolve().then(() => {\n        this[_validationRequestSymbol] = undefined;\n      });\n    }\n    return this[_validationRequestSymbol];\n  }\n\n  protected completeValidation(): void {\n    this[_validating] = false;\n    this.dispatchEvent(CHANGED);\n  }\n\n  protected override update(oldValue: T): void {\n    const onChange = this[_config]?.onChange;\n    if (onChange) {\n      onChange.call(this.#context, oldValue);\n    }\n    this.dispatchEvent(CHANGED);\n  }\n}\n"],
  "mappings": "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",
  "names": ["EndpointValidationError", "BinderNode", "CHANGED", "getDefaultFieldStrategy", "_parent", "runValidator", "ServerValidator", "ValidationError", "_submitting", "_defaultValue", "_value", "_emptyValue", "_config", "_validations", "_validating", "_validationRequestSymbol", "BinderRoot", "#context", "Model", "config", "valueContainer", "newValue", "oldValue", "value", "onSubmit", "endpointMethod", "errors", "error", "valueErrors", "data", "res", "property", "message", "model", "validator", "modelValidations", "promise", "elm", "onChange"]
}
