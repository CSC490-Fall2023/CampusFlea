{
  "version": 3,
  "sources": ["src/Validation.ts"],
  "sourcesContent": ["// TODO: Fix dependency cycle\n\n// eslint-disable-next-line import/no-cycle\n\nimport type { Binder } from './Binder.js';\nimport type { BinderNode } from './BinderNode.js';\nimport { type AbstractModel, NumberModel, getBinderNode } from './Models.js';\n// eslint-disable-next-line import/no-cycle\nimport { Required } from './Validators.js';\n\nexport interface ValueError<T> {\n  property: AbstractModel<any> | string;\n  message: string;\n  value: T;\n  validator: Validator<T>;\n}\n\nexport interface ValidationResult {\n  property: AbstractModel<any> | string;\n  message?: string;\n}\n\nexport class ValidationError extends Error {\n  errors: ReadonlyArray<ValueError<any>>;\n\n  constructor(errors: ReadonlyArray<ValueError<any>>) {\n    super(\n      [\n        'There are validation errors in the form.',\n        ...errors.map(\n          (e) => `${e.property.toString()} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ''}`,\n        ),\n      ].join('\\n - '),\n    );\n    this.errors = errors;\n    this.name = this.constructor.name;\n  }\n}\n\nexport type ValidationCallback<T> = (\n  value: T,\n  binder: Binder<unknown, AbstractModel<unknown>>,\n) =>\n  | Promise<ValidationResult | boolean | readonly ValidationResult[]>\n  | ValidationResult\n  | boolean\n  | readonly ValidationResult[];\n\nexport type InterpolateMessageCallback<T> = (\n  message: string,\n  validator: Validator<T>,\n  binderNode: BinderNode<T, AbstractModel<T>>,\n) => string;\n\nexport interface Validator<T> {\n  validate: ValidationCallback<T>;\n  message: string;\n  impliesRequired?: boolean;\n}\n\nexport class ServerValidator implements Validator<any> {\n  message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n\n  validate = (): boolean => false;\n}\n\n// The `property` field of `ValidationResult`s is a path relative to the parent.\nfunction setPropertyAbsolutePath(binderNodeName: string, result: ValidationResult): ValidationResult {\n  if (typeof result.property === 'string' && binderNodeName.length > 0) {\n    result.property = `${binderNodeName}.${result.property}`;\n  }\n  return result;\n}\n\nexport async function runValidator<T>(\n  model: AbstractModel<T>,\n  validator: Validator<T>,\n  interpolateMessageCallback?: InterpolateMessageCallback<T>,\n): Promise<ReadonlyArray<ValueError<T>>> {\n  const binderNode = getBinderNode(model);\n  const value = binderNode.value!;\n\n  const interpolateMessage = (message: string) => {\n    if (!interpolateMessageCallback) {\n      return message;\n    }\n    return interpolateMessageCallback(message, validator, binderNode);\n  };\n\n  // If model is not required and value empty, do not run any validator. Except\n  // always validate NumberModel, which has a mandatory builtin validator\n  // to indicate NaN input.\n  if (!binderNode.required && !new Required().validate(value) && !(model instanceof NumberModel)) {\n    return [];\n  }\n  return (async () => validator.validate(value, binderNode.binder))()\n    .catch((error) => {\n      console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);\n      return [{ message: 'Validator threw an error', property: binderNode.name, validator, value }];\n    })\n    .then((result) => {\n      if (result === false) {\n        return [{ message: interpolateMessage(validator.message), property: binderNode.name, validator, value }];\n      }\n      if (result === true || (Array.isArray(result) && result.length === 0)) {\n        return [];\n      }\n      if (Array.isArray(result)) {\n        return result.map((result2) => ({\n          message: interpolateMessage(validator.message),\n          ...setPropertyAbsolutePath(binderNode.name, result2),\n          validator,\n          value,\n        }));\n      }\n      return [\n        {\n          message: interpolateMessage(validator.message),\n          ...setPropertyAbsolutePath(binderNode.name, result as ValidationResult),\n          validator,\n          value,\n        },\n      ];\n    });\n}\n"],
  "mappings": "AAMA,OAA6B,eAAAA,EAAa,iBAAAC,MAAqB,cAE/D,OAAS,YAAAC,MAAgB,kBAclB,MAAMC,UAAwB,KAAM,CACzC,OAEA,YAAYC,EAAwC,CAClD,MACE,CACE,2CACA,GAAGA,EAAO,IACPC,GAAM,GAAGA,EAAE,SAAS,SAAS,CAAC,MAAMA,EAAE,UAAU,YAAY,IAAI,GAAGA,EAAE,QAAU,KAAKA,EAAE,OAAO,GAAK,EAAE,EACvG,CACF,EAAE,KAAK;AAAA,IAAO,CAChB,EACA,KAAK,OAASD,EACd,KAAK,KAAO,KAAK,YAAY,IAC/B,CACF,CAuBO,MAAME,CAA0C,CACrD,QAEA,YAAYC,EAAiB,CAC3B,KAAK,QAAUA,CACjB,CAEA,SAAW,IAAe,EAC5B,CAGA,SAASC,EAAwBC,EAAwBC,EAA4C,CACnG,OAAI,OAAOA,EAAO,UAAa,UAAYD,EAAe,OAAS,IACjEC,EAAO,SAAW,GAAGD,CAAc,IAAIC,EAAO,QAAQ,IAEjDA,CACT,CAEA,eAAsBC,EACpBC,EACAC,EACAC,EACuC,CACvC,MAAMC,EAAad,EAAcW,CAAK,EAChCI,EAAQD,EAAW,MAEnBE,EAAsBV,GACrBO,EAGEA,EAA2BP,EAASM,EAAWE,CAAU,EAFvDR,EAQX,MAAI,CAACQ,EAAW,UAAY,CAAC,IAAIb,EAAS,EAAE,SAASc,CAAK,GAAK,EAAEJ,aAAiBZ,GACzE,CAAC,GAEF,SAAYa,EAAU,SAASG,EAAOD,EAAW,MAAM,GAAG,EAC/D,MAAOG,IACN,QAAQ,MAAM,GAAGH,EAAW,IAAI,gBAAgBF,EAAU,YAAY,IAAI,mBAAoBK,CAAK,EAC5F,CAAC,CAAE,QAAS,2BAA4B,SAAUH,EAAW,KAAM,UAAAF,EAAW,MAAAG,CAAM,CAAC,EAC7F,EACA,KAAMN,GACDA,IAAW,GACN,CAAC,CAAE,QAASO,EAAmBJ,EAAU,OAAO,EAAG,SAAUE,EAAW,KAAM,UAAAF,EAAW,MAAAG,CAAM,CAAC,EAErGN,IAAW,IAAS,MAAM,QAAQA,CAAM,GAAKA,EAAO,SAAW,EAC1D,CAAC,EAEN,MAAM,QAAQA,CAAM,EACfA,EAAO,IAAKS,IAAa,CAC9B,QAASF,EAAmBJ,EAAU,OAAO,EAC7C,GAAGL,EAAwBO,EAAW,KAAMI,CAAO,EACnD,UAAAN,EACA,MAAAG,CACF,EAAE,EAEG,CACL,CACE,QAASC,EAAmBJ,EAAU,OAAO,EAC7C,GAAGL,EAAwBO,EAAW,KAAML,CAA0B,EACtE,UAAAG,EACA,MAAAG,CACF,CACF,CACD,CACL",
  "names": ["NumberModel", "getBinderNode", "Required", "ValidationError", "errors", "e", "ServerValidator", "message", "setPropertyAbsolutePath", "binderNodeName", "result", "runValidator", "model", "validator", "interpolateMessageCallback", "binderNode", "value", "interpolateMessage", "error", "result2"]
}
