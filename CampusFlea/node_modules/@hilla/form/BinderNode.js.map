{
  "version": 3,
  "sources": ["src/BinderNode.ts"],
  "sourcesContent": ["/*\n * Copyright 2000-2020 Vaadin Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n// TODO: Fix dependency cycle\n\nimport type { Binder } from './Binder.js';\n// eslint-disable-next-line import/no-cycle\nimport {\n  _binderNode,\n  _ItemModel,\n  _key,\n  _parent,\n  _validators,\n  AbstractModel,\n  ArrayModel,\n  getBinderNode,\n  ObjectModel,\n} from './Models.js';\nimport type { Validator, ValueError } from './Validation.js';\nimport { ValidityStateValidator } from './Validators.js';\nimport { _validity } from './Validity.js';\n\nconst _ownErrors = Symbol('ownErrorsSymbol');\nconst _visited = Symbol('visited');\n\nfunction getErrorPropertyName(valueError: ValueError<any>): string {\n  return typeof valueError.property === 'string' ? valueError.property : getBinderNode(valueError.property).name;\n}\n\ntype ArrayBinderNode<TItem> = BinderNode<readonly TItem[], ArrayModel<TItem, AbstractModel<TItem>>>;\n\ntype ArrayItemBinderNode<T, M extends AbstractModel<T>> = Omit<BinderNode<T, M>, 'parent'> & {\n  parent: ArrayBinderNode<T>;\n};\n\nconst defaultArrayItemCache = new WeakMap<object, unknown>();\nconst getDefaultArrayItem = <TItem>(arrayNode: ArrayBinderNode<TItem>): TItem => {\n  const cache = defaultArrayItemCache as WeakMap<typeof arrayNode, TItem>;\n  if (cache.has(arrayNode)) {\n    return defaultArrayItemCache.get(arrayNode) as TItem;\n  }\n  const defaultArrayItem = arrayNode.model[_ItemModel].createEmptyValue();\n  cache.set(arrayNode, defaultArrayItem);\n  return defaultArrayItem;\n};\n\nexport const CHANGED = new Event('binder-node-changed');\n\n/**\n * The BinderNode\\<T, M\\> class provides the form binding related APIs\n * with respect to a particular model instance.\n *\n * Structurally, model instances form a tree, in which the object\n * and array models have child nodes of field and array item model\n * instances.\n */\nexport class BinderNode<T, M extends AbstractModel<T>> extends EventTarget {\n  readonly model: M;\n\n  /**\n   * The validity state read from the bound element, if any. Represents the\n   * HTML element internal validation.\n   *\n   * For elements with `validity.valid === false`, the value in the\n   * bound element is considered as invalid.\n   */\n  [_validity]?: ValidityState;\n\n  private [_visited] = false;\n\n  private [_validators]: ReadonlyArray<Validator<T>>;\n\n  private [_ownErrors]?: ReadonlyArray<ValueError<T>>;\n\n  private readonly validityStateValidator: ValidityStateValidator<T>;\n\n  constructor(model: M) {\n    super();\n    this.model = model;\n    model[_binderNode] = this;\n    this.validityStateValidator = new ValidityStateValidator<T>();\n    this.initializeValue();\n    this[_validators] = model[_validators];\n  }\n\n  /**\n   * The parent node, if this binder node corresponds to a nested model,\n   * otherwise undefined for the top-level binder.\n   */\n  get parent(): BinderNode<unknown, AbstractModel<unknown>> | undefined {\n    const modelParent = this.model[_parent];\n    return modelParent instanceof AbstractModel ? getBinderNode(modelParent) : undefined;\n  }\n\n  /**\n   * The binder for the top-level model.\n   */\n  get binder(): Binder<unknown, AbstractModel<unknown>> {\n    return this.parent ? this.parent.binder : (this as any);\n  }\n\n  /**\n   * The name generated from the model structure, used to set the name\n   * attribute on the field components.\n   */\n  get name(): string {\n    let model = this.model as AbstractModel<any>;\n    const strings = [];\n    while (model[_parent] instanceof AbstractModel) {\n      strings.unshift(String(model[_key]));\n      model = model[_parent];\n    }\n    return strings.join('.');\n  }\n\n  /**\n   * The current value related to the model\n   */\n  get value(): T | undefined {\n    if (this.parent!.value === undefined) {\n      this.parent!.initializeValue(true);\n    }\n    const key = this.model[_key];\n    return (this.parent!.value as { readonly [key in typeof key]: T })[key];\n  }\n\n  set value(value: T | undefined) {\n    this.setValueState(value);\n  }\n\n  /**\n   * The default value related to the model\n   */\n  get defaultValue(): T {\n    if (this.isArrayItem()) {\n      const arrayNode = this.parent.asArray<T>();\n      return getDefaultArrayItem(arrayNode);\n    }\n\n    const key = this.model[_key];\n    return (this.parent!.defaultValue as { readonly [key in typeof key]: T })[key];\n  }\n\n  /**\n   * True if the current value is different from the defaultValue.\n   */\n  get dirty(): boolean {\n    return this.value !== this.defaultValue;\n  }\n\n  /**\n   * The array of validators for the model. The default value is defined in the\n   * model.\n   */\n  get validators(): ReadonlyArray<Validator<T>> {\n    return this[_validators];\n  }\n\n  set validators(validators: ReadonlyArray<Validator<T>>) {\n    this[_validators] = validators;\n    this.dispatchEvent(CHANGED);\n  }\n\n  /**\n   * True if the bound field was ever focused and blurred by the user.\n   */\n  get visited(): boolean {\n    return this[_visited];\n  }\n\n  set visited(v: boolean) {\n    if (this[_visited] !== v) {\n      this[_visited] = v;\n      this.updateValidation().catch(() => {});\n      this.dispatchEvent(CHANGED);\n    }\n  }\n\n  /**\n   * The combined array of all errors for this node\u2019s model and all its nested\n   * models\n   */\n  get errors(): ReadonlyArray<ValueError<any>> {\n    const descendantsErrors = [...this.getChildBinderNodes()].reduce<readonly any[]>(\n      (errors, childBinderNode) => [...errors, ...childBinderNode.errors],\n      [],\n    );\n    return descendantsErrors.concat(this.ownErrors);\n  }\n\n  /**\n   * The array of validation errors directly related with the model.\n   */\n  get ownErrors(): ReadonlyArray<ValueError<T>> {\n    return this[_ownErrors] ? this[_ownErrors] : [];\n  }\n\n  /**\n   * Indicates if there is any error for the node's model.\n   */\n  get invalid(): boolean {\n    return this.errors.length > 0;\n  }\n\n  /**\n   * True if the value is required to be non-empty.\n   */\n  get required(): boolean {\n    return this[_validators].some((validator) => validator.impliesRequired);\n  }\n\n  /**\n   * Returns a binder node for the nested model instance.\n   *\n   * @param model - The nested model instance\n   */\n  for<NM extends AbstractModel<any>>(model: NM): BinderNode<ReturnType<NM['valueOf']>, NM> {\n    const binderNode = getBinderNode(model);\n    if (binderNode.binder !== this.binder) {\n      throw new Error('Unknown binder');\n    }\n\n    return binderNode;\n  }\n\n  /**\n   * Runs all validation callbacks potentially affecting this\n   * or any nested model. Returns the combined array of all\n   * errors as in the errors property.\n   */\n  async validate(): Promise<ReadonlyArray<ValueError<any>>> {\n    const errors = (\n      await Promise.all([...this.requestValidationOfDescendants(), ...this.requestValidationWithAncestors()])\n    ).flat();\n    this.setErrorsWithDescendants(errors.length ? errors : undefined);\n    this.update();\n    return errors;\n  }\n\n  /**\n   * A helper method to add a validator\n   *\n   * @param validator - a validator\n   */\n  addValidator(validator: Validator<T>): void {\n    this.validators = [...this[_validators], validator];\n    this.dispatchEvent(CHANGED);\n  }\n\n  /**\n   * Append an item to the array value.\n   *\n   * Requires the context model to be an array reference.\n   *\n   * @param itemValue - optional new item value, an empty item is\n   * appended if the argument is omitted\n   */\n  appendItem<TItem extends M extends ArrayModel<infer TArrayItem, AbstractModel<any>> ? TArrayItem : never>(\n    itemValue?: TItem,\n  ): void {\n    const arrayNode = this.asArray<TItem>();\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const itemValueOrEmptyValue = itemValue ?? arrayNode.model[_ItemModel].createEmptyValue();\n    arrayNode.value = [...(arrayNode.value ?? []), itemValueOrEmptyValue];\n  }\n\n  /**\n   * Prepend an item to the array value.\n   *\n   * Requires the context model to be an array reference.\n   *\n   * @param itemValue - optional new item value, an empty item is prepended if\n   * the argument is omitted\n   */\n  prependItem<TItem extends M extends ArrayModel<infer TArrayItem, AbstractModel<any>> ? TArrayItem : never>(\n    itemValue?: TItem,\n  ): void {\n    const arrayNode = this.asArray<TItem>();\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const itemValueOrEmptyValue = itemValue ?? arrayNode.model[_ItemModel].createEmptyValue();\n    arrayNode.value = [itemValueOrEmptyValue, ...(arrayNode.value ?? [])];\n  }\n\n  /**\n   * Remove itself from the parent array value.\n   *\n   * Requires the context model to be an array item reference.\n   */\n  removeSelf(): void {\n    const arrayItemNode = this.asArrayItem();\n    const itemIndex = this.model[_key];\n    const arrayNode = arrayItemNode.parent;\n    arrayNode.value = (arrayNode.value ?? []).filter((_, i) => i !== itemIndex);\n  }\n\n  protected clearValidation(): boolean {\n    if (this[_visited]) {\n      this[_visited] = false;\n      this.dispatchEvent(CHANGED);\n    }\n    let needsUpdate = false;\n    if (this[_ownErrors]) {\n      this[_ownErrors] = undefined;\n      needsUpdate = true;\n      this.dispatchEvent(CHANGED);\n    }\n    if ([...this.getChildBinderNodes()].filter((childBinderNode) => childBinderNode.clearValidation()).length > 0) {\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n\n  protected async updateValidation(): Promise<void> {\n    if (this[_visited]) {\n      await this.validate();\n    } else if (this.dirty || this.invalid) {\n      await Promise.all(\n        [...this.getChildBinderNodes()].map(async (childBinderNode) => childBinderNode.updateValidation()),\n      );\n    }\n  }\n\n  protected update(_?: T): void {\n    if (this.parent) {\n      this.parent.update();\n    }\n  }\n\n  protected setErrorsWithDescendants(errors?: ReadonlyArray<ValueError<any>>): void {\n    const { name } = this;\n    const ownErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError) === name) : undefined;\n    const relatedErrors = errors\n      ? errors.filter((valueError) => getErrorPropertyName(valueError).startsWith(name))\n      : undefined;\n    this[_ownErrors] = ownErrors;\n    for (const childBinderNode of this.getChildBinderNodes()) {\n      childBinderNode.setErrorsWithDescendants(relatedErrors);\n    }\n    this.dispatchEvent(CHANGED);\n  }\n\n  private *getChildBinderNodes(): Generator<BinderNode<unknown, AbstractModel<unknown>>> {\n    if (this.value === undefined) {\n      // Undefined value cannot have child properties and items.\n      return;\n    }\n\n    if (this.model instanceof ObjectModel) {\n      // We need to skip all non-initialised optional fields here in order to\n      // prevent infinite recursion for circular references in the model.\n      // Here we rely on presence of keys in `defaultValue` to detect all\n      // initialised fields. The keys in `defaultValue` are defined for all\n      // non-optional fields plus those optional fields whose values were set\n      // from initial `binder.read()` or `binder.clear()` or by using a\n      // binder node (e.g., form binding) for a nested field.\n      if (this.defaultValue) {\n        for (const [, getter] of ObjectModel.getOwnAndParentGetters(this.model)) {\n          const childModel = getter.call(this.model);\n          if (childModel instanceof AbstractModel) {\n            yield getBinderNode(childModel);\n          }\n        }\n      }\n    } else if (this.model instanceof ArrayModel) {\n      for (const childBinderNode of this.model) {\n        yield childBinderNode;\n      }\n    }\n  }\n\n  private runOwnValidators(): ReadonlyArray<Promise<ReadonlyArray<ValueError<any>>>> {\n    if (this[_validity] && !this[_validity].valid) {\n      // The element's internal validation reported invalid state.\n\n      if (this[_validity].badInput) {\n        // Bad input means the `value` cannot be used and even meaningfully\n        // validated with the validators in the binder, because it cannot be\n        // parsed, for example, if a date is entered with incorrect format.\n        //\n        // Skip running the validators, and instead assume the only error\n        // from the validity state.\n        return [this.binder.requestValidation(this.model, this.validityStateValidator)];\n      }\n      // Validate the value, but also raise the error from the validity state.\n      return [...this[_validators], this.validityStateValidator].map(async (validator) =>\n        this.binder.requestValidation(this.model, validator),\n      );\n    }\n\n    return this[_validators].map(async (validator) => this.binder.requestValidation(this.model, validator));\n  }\n\n  private requestValidationOfDescendants(): ReadonlyArray<Promise<ReadonlyArray<ValueError<any>>>> {\n    return [...this.getChildBinderNodes()].reduce<ReadonlyArray<Promise<ReadonlyArray<ValueError<any>>>>>(\n      (promises, childBinderNode) => [\n        ...promises,\n        ...childBinderNode.runOwnValidators(),\n        ...childBinderNode.requestValidationOfDescendants(),\n      ],\n      [],\n    );\n  }\n\n  private requestValidationWithAncestors(): ReadonlyArray<Promise<ReadonlyArray<ValueError<any>>>> {\n    return [...this.runOwnValidators(), ...(this.parent ? this.parent.requestValidationWithAncestors() : [])];\n  }\n\n  initializeValue(forceInitialize = false): void {\n    // First, make sure parents have value initialized\n    if (this.parent && (this.parent.value === undefined || (this.parent.defaultValue as T | undefined) === undefined)) {\n      this.parent.initializeValue(true);\n    }\n\n    const key = this.model[_key];\n    let value: T | undefined = this.parent\n      ? (this.parent.value as { readonly [key in typeof key]: T })[this.model[_key]]\n      : undefined;\n\n    if (value === undefined) {\n      // Initialize value if this is the root level node, or it is enforced\n      if (forceInitialize || !this.parent) {\n        value = this.model.constructor.createEmptyValue() as T;\n        this.setValueState(value, this.defaultValue === undefined);\n      } else if (\n        this.parent.model instanceof ObjectModel &&\n        !(key in ((this.parent.value || {}) as { readonly [key in typeof key]?: T }))\n      ) {\n        this.setValueState(undefined, this.defaultValue === undefined);\n      }\n    }\n  }\n\n  private setValueState(value: T | undefined, keepPristine = false): void {\n    const modelParent = this.model[_parent];\n    const key = this.model[_key];\n    if (modelParent instanceof ObjectModel) {\n      // Value contained in object - replace object in parent\n      const object: { readonly [key in typeof key]?: T } = {\n        ...(this.parent!.value as { readonly [key in typeof key]?: T }),\n        [key]: value,\n      };\n      this.parent!.setValueState(object, keepPristine);\n      return;\n    }\n\n    if (value === undefined) {\n      throw new TypeError('Unexpected undefined value');\n    }\n\n    if (this.isArrayItem()) {\n      // Value contained in array - replace array in parent\n      const array = (this.parent.value ?? []).slice();\n      array[key as number] = value;\n      this.parent.setValueState(array, keepPristine);\n    } else {\n      // Value contained elsewhere, probably binder - use value property setter\n      const binder = modelParent as Binder<T, M>;\n      if (keepPristine && !binder.dirty) {\n        binder.defaultValue = value;\n      }\n      binder.value = value!;\n    }\n  }\n\n  private isArray<TItem>(): this is ArrayBinderNode<TItem> {\n    return this.model instanceof ArrayModel;\n  }\n\n  private asArray<TItem>(): ArrayBinderNode<TItem> {\n    if (!this.isArray()) {\n      throw new TypeError('Model is not array');\n    }\n\n    return this as ArrayBinderNode<TItem>;\n  }\n\n  private isArrayItem(): this is ArrayItemBinderNode<T, M> {\n    return this.parent?.model instanceof ArrayModel;\n  }\n\n  private asArrayItem(): ArrayItemBinderNode<T, M> {\n    if (!this.isArrayItem()) {\n      throw new TypeError('Model is not an array item');\n    }\n\n    return this as ArrayItemBinderNode<T, M>;\n  }\n}\n"],
  "mappings": "AAmBA,OACE,eAAAA,EACA,cAAAC,EACA,QAAAC,EACA,WAAAC,EACA,eAAAC,EACA,iBAAAC,EACA,cAAAC,EACA,iBAAAC,EACA,eAAAC,MACK,cAEP,OAAS,0BAAAC,MAA8B,kBACvC,OAAS,aAAAC,MAAiB,gBAE1B,MAAMC,EAAa,OAAO,iBAAiB,EACrCC,EAAW,OAAO,SAAS,EAEjC,SAASC,EAAqBC,EAAqC,CACjE,OAAO,OAAOA,EAAW,UAAa,SAAWA,EAAW,SAAWP,EAAcO,EAAW,QAAQ,EAAE,IAC5G,CAQA,MAAMC,EAAwB,IAAI,QAC5BC,EAA8BC,GAA6C,CAC/E,MAAMC,EAAQH,EACd,GAAIG,EAAM,IAAID,CAAS,EACrB,OAAOF,EAAsB,IAAIE,CAAS,EAE5C,MAAME,EAAmBF,EAAU,MAAMhB,CAAU,EAAE,iBAAiB,EACtE,OAAAiB,EAAM,IAAID,EAAWE,CAAgB,EAC9BA,CACT,EAEaC,EAAU,IAAI,MAAM,qBAAqB,EAU/C,MAAMC,UAAkD,WAAY,CAChE,MAST,CAACX,CAAS,EAEV,CAASE,CAAQ,EAAI,GAErB,CAASR,CAAW,EAEpB,CAASO,CAAU,EAEF,uBAEjB,YAAYW,EAAU,CACpB,MAAM,EACN,KAAK,MAAQA,EACbA,EAAMtB,CAAW,EAAI,KACrB,KAAK,uBAAyB,IAAIS,EAClC,KAAK,gBAAgB,EACrB,KAAKL,CAAW,EAAIkB,EAAMlB,CAAW,CACvC,CAMA,IAAI,QAAkE,CACpE,MAAMmB,EAAc,KAAK,MAAMpB,CAAO,EACtC,OAAOoB,aAAuBlB,EAAgBE,EAAcgB,CAAW,EAAI,MAC7E,CAKA,IAAI,QAAkD,CACpD,OAAO,KAAK,OAAS,KAAK,OAAO,OAAU,IAC7C,CAMA,IAAI,MAAe,CACjB,IAAID,EAAQ,KAAK,MACjB,MAAME,EAAU,CAAC,EACjB,KAAOF,EAAMnB,CAAO,YAAaE,GAC/BmB,EAAQ,QAAQ,OAAOF,EAAMpB,CAAI,CAAC,CAAC,EACnCoB,EAAQA,EAAMnB,CAAO,EAEvB,OAAOqB,EAAQ,KAAK,GAAG,CACzB,CAKA,IAAI,OAAuB,CACrB,KAAK,OAAQ,QAAU,QACzB,KAAK,OAAQ,gBAAgB,EAAI,EAEnC,MAAMC,EAAM,KAAK,MAAMvB,CAAI,EAC3B,OAAQ,KAAK,OAAQ,MAA8CuB,CAAG,CACxE,CAEA,IAAI,MAAMC,EAAsB,CAC9B,KAAK,cAAcA,CAAK,CAC1B,CAKA,IAAI,cAAkB,CACpB,GAAI,KAAK,YAAY,EAAG,CACtB,MAAMT,EAAY,KAAK,OAAO,QAAW,EACzC,OAAOD,EAAoBC,CAAS,CACtC,CAEA,MAAMQ,EAAM,KAAK,MAAMvB,CAAI,EAC3B,OAAQ,KAAK,OAAQ,aAAqDuB,CAAG,CAC/E,CAKA,IAAI,OAAiB,CACnB,OAAO,KAAK,QAAU,KAAK,YAC7B,CAMA,IAAI,YAA0C,CAC5C,OAAO,KAAKrB,CAAW,CACzB,CAEA,IAAI,WAAWuB,EAAyC,CACtD,KAAKvB,CAAW,EAAIuB,EACpB,KAAK,cAAcP,CAAO,CAC5B,CAKA,IAAI,SAAmB,CACrB,OAAO,KAAKR,CAAQ,CACtB,CAEA,IAAI,QAAQgB,EAAY,CAClB,KAAKhB,CAAQ,IAAMgB,IACrB,KAAKhB,CAAQ,EAAIgB,EACjB,KAAK,iBAAiB,EAAE,MAAM,IAAM,CAAC,CAAC,EACtC,KAAK,cAAcR,CAAO,EAE9B,CAMA,IAAI,QAAyC,CAK3C,MAJ0B,CAAC,GAAG,KAAK,oBAAoB,CAAC,EAAE,OACxD,CAACS,EAAQC,IAAoB,CAAC,GAAGD,EAAQ,GAAGC,EAAgB,MAAM,EAClE,CAAC,CACH,EACyB,OAAO,KAAK,SAAS,CAChD,CAKA,IAAI,WAA0C,CAC5C,OAAO,KAAKnB,CAAU,EAAI,KAAKA,CAAU,EAAI,CAAC,CAChD,CAKA,IAAI,SAAmB,CACrB,OAAO,KAAK,OAAO,OAAS,CAC9B,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAKP,CAAW,EAAE,KAAM2B,GAAcA,EAAU,eAAe,CACxE,CAOA,IAAmCT,EAAsD,CACvF,MAAMU,EAAazB,EAAce,CAAK,EACtC,GAAIU,EAAW,SAAW,KAAK,OAC7B,MAAM,IAAI,MAAM,gBAAgB,EAGlC,OAAOA,CACT,CAOA,MAAM,UAAoD,CACxD,MAAMH,GACJ,MAAM,QAAQ,IAAI,CAAC,GAAG,KAAK,+BAA+B,EAAG,GAAG,KAAK,+BAA+B,CAAC,CAAC,GACtG,KAAK,EACP,YAAK,yBAAyBA,EAAO,OAASA,EAAS,MAAS,EAChE,KAAK,OAAO,EACLA,CACT,CAOA,aAAaE,EAA+B,CAC1C,KAAK,WAAa,CAAC,GAAG,KAAK3B,CAAW,EAAG2B,CAAS,EAClD,KAAK,cAAcX,CAAO,CAC5B,CAUA,WACEa,EACM,CACN,MAAMhB,EAAY,KAAK,QAAe,EAEhCiB,EAAwBD,GAAahB,EAAU,MAAMhB,CAAU,EAAE,iBAAiB,EACxFgB,EAAU,MAAQ,CAAC,GAAIA,EAAU,OAAS,CAAC,EAAIiB,CAAqB,CACtE,CAUA,YACED,EACM,CACN,MAAMhB,EAAY,KAAK,QAAe,EAEhCiB,EAAwBD,GAAahB,EAAU,MAAMhB,CAAU,EAAE,iBAAiB,EACxFgB,EAAU,MAAQ,CAACiB,EAAuB,GAAIjB,EAAU,OAAS,CAAC,CAAE,CACtE,CAOA,YAAmB,CACjB,MAAMkB,EAAgB,KAAK,YAAY,EACjCC,EAAY,KAAK,MAAMlC,CAAI,EAC3Be,EAAYkB,EAAc,OAChClB,EAAU,OAASA,EAAU,OAAS,CAAC,GAAG,OAAO,CAACoB,EAAGC,IAAMA,IAAMF,CAAS,CAC5E,CAEU,iBAA2B,CAC/B,KAAKxB,CAAQ,IACf,KAAKA,CAAQ,EAAI,GACjB,KAAK,cAAcQ,CAAO,GAE5B,IAAImB,EAAc,GAClB,OAAI,KAAK5B,CAAU,IACjB,KAAKA,CAAU,EAAI,OACnB4B,EAAc,GACd,KAAK,cAAcnB,CAAO,GAExB,CAAC,GAAG,KAAK,oBAAoB,CAAC,EAAE,OAAQU,GAAoBA,EAAgB,gBAAgB,CAAC,EAAE,OAAS,IAC1GS,EAAc,IAETA,CACT,CAEA,MAAgB,kBAAkC,CAC5C,KAAK3B,CAAQ,EACf,MAAM,KAAK,SAAS,GACX,KAAK,OAAS,KAAK,UAC5B,MAAM,QAAQ,IACZ,CAAC,GAAG,KAAK,oBAAoB,CAAC,EAAE,IAAI,MAAOkB,GAAoBA,EAAgB,iBAAiB,CAAC,CACnG,CAEJ,CAEU,OAAOO,EAAa,CACxB,KAAK,QACP,KAAK,OAAO,OAAO,CAEvB,CAEU,yBAAyBR,EAA+C,CAChF,KAAM,CAAE,KAAAW,CAAK,EAAI,KACXC,EAAYZ,EAASA,EAAO,OAAQf,GAAeD,EAAqBC,CAAU,IAAM0B,CAAI,EAAI,OAChGE,EAAgBb,EAClBA,EAAO,OAAQf,GAAeD,EAAqBC,CAAU,EAAE,WAAW0B,CAAI,CAAC,EAC/E,OACJ,KAAK7B,CAAU,EAAI8B,EACnB,UAAWX,KAAmB,KAAK,oBAAoB,EACrDA,EAAgB,yBAAyBY,CAAa,EAExD,KAAK,cAActB,CAAO,CAC5B,CAEA,CAAS,qBAA8E,CACrF,GAAI,KAAK,QAAU,QAKnB,GAAI,KAAK,iBAAiBZ,GAQxB,GAAI,KAAK,aACP,SAAW,CAAC,CAAEmC,CAAM,IAAKnC,EAAY,uBAAuB,KAAK,KAAK,EAAG,CACvE,MAAMoC,EAAaD,EAAO,KAAK,KAAK,KAAK,EACrCC,aAAsBvC,IACxB,MAAME,EAAcqC,CAAU,EAElC,UAEO,KAAK,iBAAiBtC,EAC/B,UAAWwB,KAAmB,KAAK,MACjC,MAAMA,EAGZ,CAEQ,kBAA2E,CACjF,OAAI,KAAKpB,CAAS,GAAK,CAAC,KAAKA,CAAS,EAAE,MAGlC,KAAKA,CAAS,EAAE,SAOX,CAAC,KAAK,OAAO,kBAAkB,KAAK,MAAO,KAAK,sBAAsB,CAAC,EAGzE,CAAC,GAAG,KAAKN,CAAW,EAAG,KAAK,sBAAsB,EAAE,IAAI,MAAO2B,GACpE,KAAK,OAAO,kBAAkB,KAAK,MAAOA,CAAS,CACrD,EAGK,KAAK3B,CAAW,EAAE,IAAI,MAAO2B,GAAc,KAAK,OAAO,kBAAkB,KAAK,MAAOA,CAAS,CAAC,CACxG,CAEQ,gCAAyF,CAC/F,MAAO,CAAC,GAAG,KAAK,oBAAoB,CAAC,EAAE,OACrC,CAACc,EAAUf,IAAoB,CAC7B,GAAGe,EACH,GAAGf,EAAgB,iBAAiB,EACpC,GAAGA,EAAgB,+BAA+B,CACpD,EACA,CAAC,CACH,CACF,CAEQ,gCAAyF,CAC/F,MAAO,CAAC,GAAG,KAAK,iBAAiB,EAAG,GAAI,KAAK,OAAS,KAAK,OAAO,+BAA+B,EAAI,CAAC,CAAE,CAC1G,CAEA,gBAAgBgB,EAAkB,GAAa,CAEzC,KAAK,SAAW,KAAK,OAAO,QAAU,QAAc,KAAK,OAAO,eAAmC,SACrG,KAAK,OAAO,gBAAgB,EAAI,EAGlC,MAAMrB,EAAM,KAAK,MAAMvB,CAAI,EAC3B,IAAIwB,EAAuB,KAAK,OAC3B,KAAK,OAAO,MAA8C,KAAK,MAAMxB,CAAI,CAAC,EAC3E,OAEAwB,IAAU,SAERoB,GAAmB,CAAC,KAAK,QAC3BpB,EAAQ,KAAK,MAAM,YAAY,iBAAiB,EAChD,KAAK,cAAcA,EAAO,KAAK,eAAiB,MAAS,GAEzD,KAAK,OAAO,iBAAiBlB,GAC7B,EAAEiB,KAAS,KAAK,OAAO,OAAS,CAAC,KAEjC,KAAK,cAAc,OAAW,KAAK,eAAiB,MAAS,EAGnE,CAEQ,cAAcC,EAAsBqB,EAAe,GAAa,CACtE,MAAMxB,EAAc,KAAK,MAAMpB,CAAO,EAChCsB,EAAM,KAAK,MAAMvB,CAAI,EAC3B,GAAIqB,aAAuBf,EAAa,CAEtC,MAAMwC,EAA+C,CACnD,GAAI,KAAK,OAAQ,MACjB,CAACvB,CAAG,EAAGC,CACT,EACA,KAAK,OAAQ,cAAcsB,EAAQD,CAAY,EAC/C,MACF,CAEA,GAAIrB,IAAU,OACZ,MAAM,IAAI,UAAU,4BAA4B,EAGlD,GAAI,KAAK,YAAY,EAAG,CAEtB,MAAMuB,GAAS,KAAK,OAAO,OAAS,CAAC,GAAG,MAAM,EAC9CA,EAAMxB,CAAa,EAAIC,EACvB,KAAK,OAAO,cAAcuB,EAAOF,CAAY,CAC/C,KAAO,CAEL,MAAMG,EAAS3B,EACXwB,GAAgB,CAACG,EAAO,QAC1BA,EAAO,aAAexB,GAExBwB,EAAO,MAAQxB,CACjB,CACF,CAEQ,SAAiD,CACvD,OAAO,KAAK,iBAAiBpB,CAC/B,CAEQ,SAAyC,CAC/C,GAAI,CAAC,KAAK,QAAQ,EAChB,MAAM,IAAI,UAAU,oBAAoB,EAG1C,OAAO,IACT,CAEQ,aAAiD,CACvD,OAAO,KAAK,QAAQ,iBAAiBA,CACvC,CAEQ,aAAyC,CAC/C,GAAI,CAAC,KAAK,YAAY,EACpB,MAAM,IAAI,UAAU,4BAA4B,EAGlD,OAAO,IACT,CACF",
  "names": ["_binderNode", "_ItemModel", "_key", "_parent", "_validators", "AbstractModel", "ArrayModel", "getBinderNode", "ObjectModel", "ValidityStateValidator", "_validity", "_ownErrors", "_visited", "getErrorPropertyName", "valueError", "defaultArrayItemCache", "getDefaultArrayItem", "arrayNode", "cache", "defaultArrayItem", "CHANGED", "BinderNode", "model", "modelParent", "strings", "key", "value", "validators", "v", "errors", "childBinderNode", "validator", "binderNode", "itemValue", "itemValueOrEmptyValue", "arrayItemNode", "itemIndex", "_", "i", "needsUpdate", "name", "ownErrors", "relatedErrors", "getter", "childModel", "promises", "forceInitialize", "keepPristine", "object", "array", "binder"]
}
