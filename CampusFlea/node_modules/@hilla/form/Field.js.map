{
  "version": 3,
  "sources": ["src/Field.ts"],
  "sourcesContent": ["/* eslint-disable accessor-pairs,sort-keys */\nimport { type ElementPart, noChange, nothing, type PropertyPart } from 'lit';\nimport { directive, Directive, type DirectiveParameters, type PartInfo, PartType } from 'lit/directive.js';\nimport {\n  _fromString,\n  type AbstractModel,\n  ArrayModel,\n  BooleanModel,\n  ObjectModel,\n  getBinderNode,\n  hasFromString,\n} from './Models.js';\nimport type { ValueError } from './Validation.js';\nimport { _validity, defaultValidity } from './Validity.js';\n\nexport interface FieldBase<T> {\n  required: boolean;\n  invalid: boolean;\n  errorMessage: string;\n  value: T | undefined;\n}\n\n/**\n * Subset of the HTML constraint validation API with the `checkValidity()` method.\n */\nexport type FieldConstraintValidation = Readonly<{\n  validity: ValidityState;\n  checkValidity(): boolean;\n}>;\n\nexport type FieldElement<T> = FieldBase<T> & HTMLElement & Partial<FieldConstraintValidation>;\n\nconst props = ['required', 'invalid', 'errorMessage', 'value', 'validity', 'checkValidity'];\nexport function isFieldElement<T>(element: HTMLElement): element is FieldElement<T> {\n  return props.some((prop) => prop in element);\n}\n\ninterface FieldElementHolder<T> {\n  get element(): FieldElement<T>;\n\n  /**\n   * @param element - the new element value\n   * @deprecated will be read-only in future\n   */\n  set element(element: FieldElement<T>);\n}\n\ninterface Field<T> extends FieldBase<T> {\n  readonly model?: AbstractModel<T>;\n}\n\ninterface FieldState<T> extends Field<T>, FieldElementHolder<T> {\n  name: string;\n  validity: ValidityState;\n  strategy: FieldStrategy<T>;\n}\n\nexport type FieldStrategy<T = any> = Field<T> &\n  FieldConstraintValidation & {\n    removeEventListeners(): void;\n  };\n\nexport abstract class AbstractFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>>\n  implements FieldStrategy<T>\n{\n  abstract required: boolean;\n\n  abstract invalid: boolean;\n\n  readonly model?: AbstractModel<T>;\n\n  private _element: E;\n\n  /**\n   * @privateRemarks\n   * Fallback for missing .validity property API in Vaadin components.\n   */\n  private _validityFallback: ValidityState = defaultValidity;\n\n  constructor(element: E, model?: AbstractModel<T>) {\n    this._element = element;\n    this.model = model;\n  }\n\n  get element(): E {\n    return this._element;\n  }\n\n  /**\n   * @param element - the new element value\n   * @deprecated will be read-only in future\n   */\n  set element(element: E) {\n    this._element = element;\n  }\n\n  get value(): T | undefined {\n    return this.element.value;\n  }\n\n  set value(value: T | undefined) {\n    this.element.value = value;\n  }\n\n  set errorMessage(_: string) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  get validity(): ValidityState {\n    return this.element.validity ?? this._validityFallback;\n  }\n\n  checkValidity(): boolean {\n    if (!this.element.checkValidity) {\n      return true;\n    }\n\n    const valid = this.element.checkValidity();\n    this._validityFallback = {\n      ...defaultValidity,\n      valid,\n      ...(valid ? {} : this._detectValidityError()),\n    };\n    return valid;\n  }\n\n  setAttribute(key: string, val: any): void {\n    if (val) {\n      this.element.setAttribute(key, '');\n    } else {\n      this.element.removeAttribute(key);\n    }\n  }\n\n  removeEventListeners(): void {}\n\n  private _detectValidityError(): Readonly<Partial<ValidityState>> {\n    if (!('inputElement' in this.element)) {\n      // Not a Vaadin component field\n      return { customError: true };\n    }\n\n    const inputElement = this.element.inputElement as FieldElement<string>;\n\n    if (this.element.value === '') {\n      if (inputElement.value === '') {\n        return { valueMissing: true };\n      }\n      // Some value is entered, but not meaningful to the\n      // web component \u2014 assume parse error.\n      return { badInput: true };\n    }\n    // Unknown constraint violation\n    return { customError: true };\n  }\n}\n\nexport class VaadinFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<\n  T,\n  E\n> {\n  private _invalid = false;\n  private readonly _boundOnValidated = this._onValidated.bind(this);\n\n  constructor(element: E, model?: AbstractModel<T>) {\n    super(element, model);\n\n    (element as EventTarget).addEventListener('validated', this._boundOnValidated);\n  }\n\n  set required(value: boolean) {\n    this.element.required = value;\n  }\n\n  set invalid(value: boolean) {\n    this._invalid = value;\n    this.element.invalid = value;\n  }\n\n  override set errorMessage(value: string) {\n    this.element.errorMessage = value;\n  }\n\n  override removeEventListeners(): void {\n    this.element.removeEventListener('validated', this._boundOnValidated);\n  }\n\n  private _onValidated(e: Event): void {\n    if (!(e instanceof CustomEvent) || typeof e.detail !== 'object') {\n      return;\n    }\n\n    // Override built-in changes of the `invalid` flag in Vaadin components\n    // to keep the `invalid` property state of the web component in sync.\n    const invalid = !(e.detail satisfies Partial<ValidityState> as Partial<ValidityState>).valid;\n    if (this._invalid !== invalid) {\n      this.element.invalid = this._invalid;\n    }\n  }\n}\n\nexport class GenericFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<\n  T,\n  E\n> {\n  set required(value: boolean) {\n    this.setAttribute('required', value);\n  }\n\n  set invalid(value: boolean) {\n    this.setAttribute('invalid', value);\n  }\n}\n\ntype CheckedFieldElement<T> = FieldElement<T> & {\n  checked: boolean;\n};\n\nexport class CheckedFieldStrategy<\n  T = any,\n  E extends CheckedFieldElement<T> = CheckedFieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    if (this.model instanceof BooleanModel) {\n      return this.element.checked as T;\n    }\n\n    return this.element.checked ? this.element.value : undefined;\n  }\n\n  override set value(val: T | undefined) {\n    (this.element as { checked: boolean }).checked = /^(true|on)$/iu.test(String(val));\n  }\n}\n\ntype ComboBoxFieldElement<T> = FieldElement<T> & {\n  value: string;\n  selectedItem: T | null;\n};\n\nexport class ComboBoxFieldStrategy<\n  T,\n  E extends ComboBoxFieldElement<T> = ComboBoxFieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {\n      const { selectedItem } = this.element;\n      return (selectedItem === null ? undefined : selectedItem) as T;\n    }\n\n    return super.value;\n  }\n\n  override set value(val: T | undefined) {\n    if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {\n      this.element.selectedItem = val === undefined ? null : val;\n    } else {\n      super.value = val;\n    }\n  }\n}\n\ntype MultiSelectComboBoxFieldElement<T> = FieldElement<T> & {\n  value: never;\n  selectedItems: T;\n};\n\nexport class MultiSelectComboBoxFieldStrategy<\n  T,\n  E extends MultiSelectComboBoxFieldElement<T> = MultiSelectComboBoxFieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T {\n    return this.element.selectedItems;\n  }\n\n  override set value(val: any) {\n    this.element.selectedItems = val;\n  }\n}\n\ntype SelectedFieldElement<T> = FieldElement<T> & {\n  value: never;\n  selected: T;\n};\n\nexport class SelectedFieldStrategy<\n  T,\n  E extends SelectedFieldElement<T> = SelectedFieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T {\n    return this.element.selected;\n  }\n\n  override set value(val: T) {\n    this.element.selected = val;\n  }\n}\n\ntype MaybeVaadinElementConstructor = {\n  readonly version?: string;\n};\n\nexport function getDefaultFieldStrategy<T>(elm: FieldElement<T>, model?: AbstractModel<T>): AbstractFieldStrategy<T> {\n  switch (elm.localName) {\n    case 'vaadin-checkbox':\n    case 'vaadin-radio-button':\n      return new CheckedFieldStrategy(elm as CheckedFieldElement<T>, model);\n    case 'vaadin-combo-box':\n      return new ComboBoxFieldStrategy(elm as ComboBoxFieldElement<T>, model);\n    case 'vaadin-list-box':\n      return new SelectedFieldStrategy(elm as SelectedFieldElement<T>, model);\n    case 'vaadin-multi-select-combo-box':\n      return new MultiSelectComboBoxFieldStrategy(elm as MultiSelectComboBoxFieldElement<T>, model);\n    case 'vaadin-rich-text-editor':\n      return new GenericFieldStrategy(elm, model);\n    default:\n      if (elm.localName === 'input' && /^(checkbox|radio)$/u.test((elm as unknown as HTMLInputElement).type)) {\n        return new CheckedFieldStrategy(elm as CheckedFieldElement<T>, model);\n      }\n      return (elm.constructor as unknown as MaybeVaadinElementConstructor).version\n        ? new VaadinFieldStrategy(elm, model)\n        : new GenericFieldStrategy(elm, model);\n  }\n}\n\nfunction convertFieldValue<T extends AbstractModel<unknown>>(model: T, fieldValue: unknown) {\n  return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;\n}\n\n/**\n * Binds a form field component into a model.\n *\n * Example usage:\n *\n * ```\n * <vaadin-text-field ...=\"${field(model.name)}\">\n * </vaadin-text-field>\n * ```\n */\nexport const field = directive(\n  class extends Directive {\n    fieldState?: FieldState<any>;\n\n    constructor(partInfo: PartInfo) {\n      super(partInfo);\n      if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {\n        throw new Error('Use as \"<element {field(...)}\" or <element ...={field(...)}\"');\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    override render(_model: AbstractModel<any>, _effect?: (element: Element) => void) {\n      return nothing;\n    }\n\n    override update(part: ElementPart | PropertyPart, [model, effect]: DirectiveParameters<this>) {\n      const element = part.element as FieldElement<any> & HTMLInputElement;\n\n      const binderNode = getBinderNode(model);\n\n      if (!this.fieldState) {\n        const fieldState = {\n          errorMessage: '',\n          name: '',\n          value: '',\n          required: false,\n          invalid: false,\n          model,\n          validity: defaultValidity,\n          element,\n          strategy: binderNode.binder.getFieldStrategy(element, model),\n        };\n\n        this.fieldState = fieldState;\n\n        const updateValueFromElement = () => {\n          fieldState.strategy.checkValidity();\n          // When bad input is detected, skip reading new value in binder state\n          if (!fieldState.strategy.validity.badInput) {\n            fieldState.value = fieldState.strategy.value;\n          }\n          fieldState.validity = fieldState.strategy.validity;\n          binderNode[_validity] = fieldState.validity;\n          binderNode.value = convertFieldValue(model, fieldState.value);\n          if (effect !== undefined) {\n            effect.call(element, element);\n          }\n        };\n\n        element.addEventListener('input', updateValueFromElement);\n\n        const changeBlurHandler = () => {\n          updateValueFromElement();\n          binderNode.visited = true;\n        };\n\n        element.addEventListener('blur', changeBlurHandler);\n        element.addEventListener('change', changeBlurHandler);\n      }\n\n      const { fieldState } = this;\n\n      if (fieldState.element !== element || fieldState.model !== model) {\n        fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);\n      }\n\n      const { name } = binderNode;\n      if (name !== fieldState.name) {\n        fieldState.name = name;\n        element.setAttribute('name', name);\n      }\n\n      const { value } = binderNode;\n      const valueFromField = convertFieldValue(model, fieldState.value);\n      if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {\n        fieldState.value = value;\n        fieldState.strategy.value = value;\n      }\n\n      const { required } = binderNode;\n      if (required !== fieldState.required) {\n        fieldState.required = required;\n        fieldState.strategy.required = required;\n      }\n\n      const firstError: ValueError<any> | undefined = binderNode.ownErrors[0];\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const errorMessage = firstError?.message || '';\n      if (errorMessage !== fieldState.errorMessage) {\n        fieldState.errorMessage = errorMessage;\n        fieldState.strategy.errorMessage = errorMessage;\n      }\n\n      const { invalid } = binderNode;\n      if (invalid !== fieldState.invalid) {\n        fieldState.invalid = invalid;\n        fieldState.strategy.invalid = invalid;\n      }\n\n      return noChange;\n    }\n  },\n);\n"],
  "mappings": "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",
  "names": ["noChange", "nothing", "directive", "Directive", "PartType", "_fromString", "ArrayModel", "BooleanModel", "ObjectModel", "getBinderNode", "hasFromString", "_validity", "defaultValidity", "props", "isFieldElement", "element", "prop", "AbstractFieldStrategy", "model", "value", "_", "valid", "key", "val", "inputElement", "VaadinFieldStrategy", "invalid", "GenericFieldStrategy", "CheckedFieldStrategy", "ComboBoxFieldStrategy", "selectedItem", "MultiSelectComboBoxFieldStrategy", "SelectedFieldStrategy", "getDefaultFieldStrategy", "elm", "convertFieldValue", "fieldValue", "field", "partInfo", "_model", "_effect", "part", "effect", "binderNode", "fieldState", "updateValueFromElement", "changeBlurHandler", "name", "valueFromField", "required", "errorMessage"]
}
