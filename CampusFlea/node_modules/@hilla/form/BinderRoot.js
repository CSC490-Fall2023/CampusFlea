import{EndpointValidationError as g}from"@hilla/frontend/EndpointErrors.js";import{BinderNode as b,CHANGED as r}from"./BinderNode.js";import{getDefaultFieldStrategy as E}from"./Field.js";import{_parent as M}from"./Models.js";import{runValidator as S,ServerValidator as C,ValidationError as m}from"./Validation.js";const d=Symbol("submitting"),u=Symbol("defaultValue"),n=Symbol("value"),h=Symbol("emptyValue"),p=Symbol("config"),o=Symbol("validations"),c=Symbol("validating"),l=Symbol("validationRequest");class f extends b{static interpolateMessageCallback;[u];[n];[h];[d]=!1;[c]=!1;[l];[p];[o]=new Map;#t=this;constructor(t,e){const i={value:void 0};super(new t(i,"value",!1)),this[h]=i.value,this.model[M]=this,this.#t=e?.context??this,this[p]=e,this.read(this[h])}get defaultValue(){return this[u]}set defaultValue(t){this[u]=t,this.dispatchEvent(r)}get value(){return this[n]}set value(t){if(t===this[n])return;const e=this[n];this[n]=t,this.update(e),this.updateValidation().catch(()=>{})}get submitting(){return this[d]}get validating(){return this[c]}read(t){if(t==null){this.clear();return}this.defaultValue=t,this.value&&this.clearValidation()&&this.value===t&&this.update(this.value),this.value=this.defaultValue}reset(){this.read(this[u])}clear(){this.read(this[h])}async submit(){const t=this[p]?.onSubmit;if(t)return this.submitTo(t)}async submitTo(t){const e=await this.validate();if(e.length)throw new m(e);this[d]=!0,this.update(this.value),this.dispatchEvent(r);try{return await t.call(this.#t,this.value)}catch(i){if(i instanceof g&&i.validationErrorData.length){const a=[];throw i.validationErrorData.forEach(s=>{const v=/Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(s.message),[V,T,y]=v?v.splice(2):[s.parameterName??"",void 0,s.message];a.push({message:y,property:V,validator:new C(y),value:T})}),this.setErrorsWithDescendants(a),new m(a)}throw i}finally{this[d]=!1,this.defaultValue=this.value,this.update(this.value)}}async requestValidation(t,e){let i;if(this[o].has(t)?i=this[o].get(t):(i=new Map,this[o].set(t,i)),await this.performValidation(),i.has(e))return i.get(e);const a=S(t,e,f.interpolateMessageCallback);i.set(e,a);const s=await a;return i.delete(e),i.size===0&&this[o].delete(t),this[o].size===0&&this.completeValidation(),s}getFieldStrategy(t,e){return E(t,e)}performValidation(){return this[l]||(this[c]=!0,this.dispatchEvent(r),this[l]=Promise.resolve().then(()=>{this[l]=void 0})),this[l]}completeValidation(){this[c]=!1,this.dispatchEvent(r)}update(t){const e=this[p]?.onChange;e&&e.call(this.#t,t),this.dispatchEvent(r)}}export{f as BinderRoot,r as CHANGED};
//# sourceMappingURL=BinderRoot.js.map
