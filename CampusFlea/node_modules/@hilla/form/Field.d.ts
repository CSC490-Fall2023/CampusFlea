import { type ElementPart, type PropertyPart } from 'lit';
import { type PartInfo } from 'lit/directive.js';
import { type AbstractModel } from './Models.js';
export interface FieldBase<T> {
    required: boolean;
    invalid: boolean;
    errorMessage: string;
    value: T | undefined;
}
/**
 * Subset of the HTML constraint validation API with the `checkValidity()` method.
 */
export type FieldConstraintValidation = Readonly<{
    validity: ValidityState;
    checkValidity(): boolean;
}>;
export type FieldElement<T> = FieldBase<T> & HTMLElement & Partial<FieldConstraintValidation>;
export declare function isFieldElement<T>(element: HTMLElement): element is FieldElement<T>;
interface FieldElementHolder<T> {
    get element(): FieldElement<T>;
    /**
     * @param element - the new element value
     * @deprecated will be read-only in future
     */
    set element(element: FieldElement<T>);
}
interface Field<T> extends FieldBase<T> {
    readonly model?: AbstractModel<T>;
}
interface FieldState<T> extends Field<T>, FieldElementHolder<T> {
    name: string;
    validity: ValidityState;
    strategy: FieldStrategy<T>;
}
export type FieldStrategy<T = any> = Field<T> & FieldConstraintValidation & {
    removeEventListeners(): void;
};
export declare abstract class AbstractFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> implements FieldStrategy<T> {
    abstract required: boolean;
    abstract invalid: boolean;
    readonly model?: AbstractModel<T>;
    private _element;
    /**
     * @privateRemarks
     * Fallback for missing .validity property API in Vaadin components.
     */
    private _validityFallback;
    constructor(element: E, model?: AbstractModel<T>);
    get element(): E;
    /**
     * @param element - the new element value
     * @deprecated will be read-only in future
     */
    set element(element: E);
    get value(): T | undefined;
    set value(value: T | undefined);
    set errorMessage(_: string);
    get validity(): ValidityState;
    checkValidity(): boolean;
    setAttribute(key: string, val: any): void;
    removeEventListeners(): void;
    private _detectValidityError;
}
export declare class VaadinFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<T, E> {
    private _invalid;
    private readonly _boundOnValidated;
    constructor(element: E, model?: AbstractModel<T>);
    set required(value: boolean);
    set invalid(value: boolean);
    set errorMessage(value: string);
    removeEventListeners(): void;
    private _onValidated;
}
export declare class GenericFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<T, E> {
    set required(value: boolean);
    set invalid(value: boolean);
}
type CheckedFieldElement<T> = FieldElement<T> & {
    checked: boolean;
};
export declare class CheckedFieldStrategy<T = any, E extends CheckedFieldElement<T> = CheckedFieldElement<T>> extends GenericFieldStrategy<T, E> {
    get value(): T | undefined;
    set value(val: T | undefined);
}
type ComboBoxFieldElement<T> = FieldElement<T> & {
    value: string;
    selectedItem: T | null;
};
export declare class ComboBoxFieldStrategy<T, E extends ComboBoxFieldElement<T> = ComboBoxFieldElement<T>> extends VaadinFieldStrategy<T, E> {
    get value(): T | undefined;
    set value(val: T | undefined);
}
type MultiSelectComboBoxFieldElement<T> = FieldElement<T> & {
    value: never;
    selectedItems: T;
};
export declare class MultiSelectComboBoxFieldStrategy<T, E extends MultiSelectComboBoxFieldElement<T> = MultiSelectComboBoxFieldElement<T>> extends VaadinFieldStrategy<T, E> {
    get value(): T;
    set value(val: any);
}
type SelectedFieldElement<T> = FieldElement<T> & {
    value: never;
    selected: T;
};
export declare class SelectedFieldStrategy<T, E extends SelectedFieldElement<T> = SelectedFieldElement<T>> extends GenericFieldStrategy<T, E> {
    get value(): T;
    set value(val: T);
}
export declare function getDefaultFieldStrategy<T>(elm: FieldElement<T>, model?: AbstractModel<T>): AbstractFieldStrategy<T>;
/**
 * Binds a form field component into a model.
 *
 * Example usage:
 *
 * ```
 * <vaadin-text-field ...="${field(model.name)}">
 * </vaadin-text-field>
 * ```
 */
export declare const field: (_model: AbstractModel<any>, _effect?: ((element: Element) => void) | undefined) => import("lit-html/directive.js").DirectiveResult<{
    new (partInfo: PartInfo): {
        fieldState?: FieldState<any> | undefined;
        render(_model: AbstractModel<any>, _effect?: ((element: Element) => void) | undefined): symbol;
        update(part: ElementPart | PropertyPart, [model, effect]: [_model: AbstractModel<any>, _effect?: ((element: Element) => void) | undefined]): symbol;
        readonly _$isConnected: boolean;
    };
}>;
export {};
//# sourceMappingURL=Field.d.ts.map