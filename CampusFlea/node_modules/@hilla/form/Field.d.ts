import { type ElementPart, type PropertyPart } from 'lit';
import { type PartInfo } from 'lit/directive.js';
import { type AbstractModel } from './Models.js';
interface FieldBase<T> {
    required: boolean;
    invalid: boolean;
    errorMessage: string;
    value: T;
}
/**
 * Subset of the HTML constraint validation API with the `checkValidity()` method.
 */
type FieldConstraintValidation = Readonly<{
    validity: ValidityState;
    checkValidity(): boolean;
}>;
type FieldElement<T> = Element & FieldBase<T> & Partial<FieldConstraintValidation>;
interface FieldElementHolder<T> {
    get element(): FieldElement<T>;
    /**
     * @param element the new element value
     * @deprecated will be read-only in future
     */
    set element(element: FieldElement<T>);
}
interface Field<T> extends FieldBase<T> {
    readonly model?: AbstractModel<T>;
}
interface FieldState<T> extends Field<T>, FieldElementHolder<T> {
    name: string;
    validity: ValidityState;
    strategy: FieldStrategy<T>;
}
export type FieldStrategy<T = any> = Field<T> & FieldConstraintValidation;
export declare abstract class AbstractFieldStrategy<T = any> implements FieldStrategy<T> {
    readonly model?: AbstractModel<T> | undefined;
    abstract required: boolean;
    abstract invalid: boolean;
    private _element;
    /**
     * Fallback for missing .validity property API in Vaadin components.
     * @private
     */
    private _validityFallback;
    constructor(element: FieldElement<T>, model?: AbstractModel<T> | undefined);
    get element(): FieldElement<T>;
    /**
     * @param element the new element value
     * @deprecated will be read-only in future
     */
    set element(element: FieldElement<T>);
    get value(): T;
    set value(value: T);
    set errorMessage(_: string);
    setAttribute(key: string, val: any): void;
    get validity(): ValidityState;
    checkValidity(): boolean;
    private _detectValidityError;
}
export declare class VaadinFieldStrategy<T = any> extends AbstractFieldStrategy<T> {
    private _invalid;
    constructor(element: FieldElement<T>, model?: AbstractModel<T>);
    set required(value: boolean);
    set invalid(value: boolean);
    set errorMessage(value: string);
    private _overrideVaadinInvalidChange;
}
export declare class GenericFieldStrategy extends AbstractFieldStrategy {
    set required(value: boolean);
    set invalid(value: boolean);
}
export declare class CheckedFieldStrategy extends GenericFieldStrategy {
    set value(val: any);
    get value(): any;
}
export declare class ComboBoxFieldStrategy extends VaadinFieldStrategy {
    get value(): any;
    set value(val: any);
}
export declare class MultiSelectComboBoxFieldStrategy extends VaadinFieldStrategy {
    get value(): any;
    set value(val: any);
}
export declare class SelectedFieldStrategy extends GenericFieldStrategy {
    set value(val: any);
    get value(): any;
}
export declare function getDefaultFieldStrategy<T>(elm: any, model?: AbstractModel<T>): AbstractFieldStrategy<T>;
/**
 * Binds a form field component into a model.
 *
 * Example usage:
 *
 * ```
 * <vaadin-text-field ...="${field(model.name)}">
 * </vaadin-text-field>
 * ```
 */
export declare const field: (model: AbstractModel<any>, effect?: ((element: Element) => void) | undefined) => import("lit-html/directive.js").DirectiveResult<{
    new (partInfo: PartInfo): {
        fieldState?: FieldState<any> | undefined;
        render(model: AbstractModel<any>, effect?: ((element: Element) => void) | undefined): symbol;
        update(part: ElementPart | PropertyPart, [model, effect]: [model: AbstractModel<any>, effect?: ((element: Element) => void) | undefined]): symbol;
        readonly _$isConnected: boolean;
    };
}>;
export {};
//# sourceMappingURL=Field.d.ts.map